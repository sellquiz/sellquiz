var sellquiz = (function (exports, math, $) {
  'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        }
      });
    }
    n['default'] = e;
    return Object.freeze(n);
  }

  var math__namespace = /*#__PURE__*/_interopNamespace(math);
  var $__namespace = /*#__PURE__*/_interopNamespace($);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  /******************************************************************************
   * SELL - SIMPLE E-LEARNING LANGUAGE                                          *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  function sellassert(cond) {
    var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

    if (!cond) {
      console.log(msg);

      if (typeof process !== 'undefined') {
        process.exit(-1);
      } else {
        alert(msg);
      }
    }
  }

  var symtype;

  (function (symtype) {
    symtype["T_UNKNOWN"] = "T_UNKNOWN";
    symtype["T_REAL"] = "T_REAL";
    symtype["T_DOTS"] = "T_DOTS";
    symtype["T_SET"] = "T_SET";
    symtype["T_BOOL"] = "T_BOOL";
    symtype["T_FUNCTION"] = "T_FUNCTION";
    symtype["T_COMPLEX"] = "T_COMPLEX";
    symtype["T_COMPLEX_SET"] = "T_COMPLEX_SET";
    symtype["T_MATRIX"] = "T_MATRIX";
    symtype["T_MATRIX_DEF"] = "T_MATRIX_DEF";
    symtype["T_MATRIX_TRANSPOSE"] = "T_MATRIX_TRANSPOSE";
    symtype["T_MATRIX_OF_FUNCTIONS"] = "T_MATRIX_OF_FUNCTIONS";
    symtype["T_STRING"] = "T_STRING";
    symtype["T_STRING_LIST"] = "T_STRING_LIST";
    symtype["T_JAVA_PROGRAMMING"] = "T_JAVA_PROGRAMMING";
  })(symtype || (symtype = {}));

  var SellSymbol = /*#__PURE__*/function () {
    function SellSymbol() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : symtype.T_UNKNOWN;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-9;

      _classCallCheck(this, SellSymbol);

      this.hint_html = '';
      this.type = type;
      this.value = value;
      this.precision = precision;
    }

    _createClass(SellSymbol, [{
      key: "exportDictionary",
      value: function exportDictionary(symid) {
        var d = {};
        d["id"] = symid;
        d["type"] = this.type;
        d["value"] = this.value.toString();
        d["precision"] = this.precision;
        d["hint"] = this.hint_html;
        return d;
      }
    }, {
      key: "importDictionary",
      value: function importDictionary(d) {
        this.type = symtype[d["type"]];

        switch (this.type) {
          case symtype.T_REAL:
            this.value = parseFloat(d["value"]);
            break;

          default:
            sellassert(false, "SellSymbol:importFromDictionary(): UNIMPLMENTED");
        }

        this.precision = d["precision"];
        this.hint_html = d["hint"];
      }
    }, {
      key: "toAsciiMath",
      value: function toAsciiMath() {
        var s = "";

        switch (this.type) {
          case symtype.T_BOOL:
            return this.value ? "true" : "false";
          // TODO: language

          case symtype.T_UNKNOWN:
            return "ERROR";

          case symtype.T_REAL:
            return this.value;

          case symtype.T_DOTS:
            return "...";

          case symtype.T_SET:
          case symtype.T_COMPLEX_SET:
            s = "{ ";

            for (var i = 0; i < this.value.length; i++) {
              s += (i > 0 ? ", " : "") + this.value[i].toAsciiMath();
            }

            s += " }";
            return s;

          case symtype.T_FUNCTION:
            s = this.value.toString();
            return s;

          case symtype.T_COMPLEX:
            s = this.value.toString(); //s = s.replace("i", "j"); // TODO: must be configurable

            return s;

          case symtype.T_MATRIX:
          case symtype.T_MATRIX_OF_FUNCTIONS:
            s = this.value.toString();
            s = s.replaceAll("[", "("); // TODO: must be configurable

            s = s.replaceAll("]", ")"); // TODO: must be configurable

            return s;

          default:
            sellassert(false, "unimplemented SellSymbol::toAsciiMath(..)");
        }
      }
    }]);

    return SellSymbol;
  }();

  /******************************************************************************
   * SELL - SIMPLE E-LEARNING LANGUAGE                                          *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  var SellToken = function SellToken(str, line, col) {
    _classCallCheck(this, SellToken);

    this.str = str;
    this.line = line; // line number

    this.col = col; // column number
  }; // end of class SellToken

  var Lexer = /*#__PURE__*/function () {
    function Lexer() {
      _classCallCheck(this, Lexer);
    }

    _createClass(Lexer, null, [{
      key: "isAlpha",
      value: function isAlpha(ch) {
        return ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z' || ch == '_' || ch == 'Ä' || ch == 'Ö' || ch == 'Ü' || ch == 'ß' || ch == 'ä' || ch == 'ö' || ch == 'ü';
      }
    }, {
      key: "isNum",
      value: function isNum(ch) {
        return ch >= '1' && ch <= '9';
      }
    }, {
      key: "isNum0",
      value: function isNum0(ch) {
        return ch == '0' || this.isNum(ch);
      }
    }, {
      key: "isIdentifier",
      value: function isIdentifier(str) {
        for (var i = 0; i < str.length; i++) {
          var ch = str[i];

          if (i == 0) {
            if (this.isAlpha(ch) == false) return false;
          } else {
            if (this.isAlpha(ch) == false && this.isNum0(ch) == false) return false;
          }
        }

        return true;
      } // integer = [ "-"], num { num0 };

    }, {
      key: "isInteger",
      value: function isInteger(str) {
        // TODO: e.g. "0123" must return false    TODO: parseUnary  uses this function including leading zeros...
        if (str.length == 0) return false;
        var startIdx = 0;

        if (str[0] === '-') {
          startIdx = 1;
          if (str.length == 1) return false;
        }

        for (var i = startIdx; i < str.length; i++) {
          var ch = str[i];
          if (this.isNum0(ch) == false) return false;
        }

        return true;
      }
    }, {
      key: "isReal",
      value: function isReal(str) {
        return isNaN(parseFloat(str)) == false;
      }
    }, {
      key: "tokenize",
      value: function tokenize(s) {
        var tokens = new Array();
        var str = '';
        var str_col = 1;
        var lineIdx = 1;
        var colIdx = 1;
        var allowUnderscoredelimiter = !s.startsWith('\t') && !s.startsWith('    '); //let allowUnderscoredelimiter = false;

        for (var i = 0; i < s.length; i++) {
          var ch = s[i];
          var ch2 = '';
          if (i < s.length - 1) ch2 = s[i + 1];
          var ch3 = '';
          if (i < s.length - 2) ch3 = s[i + 2];

          switch (ch) {
            case ' ':
            case '\t':
            case '\n':
              if (str.length > 0) tokens.push(new SellToken(str, lineIdx, str_col));
              str = '';
              str_col = colIdx;

              if (ch === '\n') {
                lineIdx++;
                colIdx = 0;
              } else if (ch === ' ') {
                tokens.push(new SellToken(ch, lineIdx, str_col));
              }

              break;

            case '_':
              if (allowUnderscoredelimiter) {
                if (str.length > 0) tokens.push(new SellToken(str, lineIdx, str_col));
                str = '';
                str_col = colIdx;

                if (ch == '_' && ch2 == '_') {
                  ch = "__";
                  i++;
                }

                tokens.push(new SellToken(ch, lineIdx, str_col));
                str_col = colIdx;
              } else {
                if (str.length == 0) str_col = colIdx;
                str += ch;
              }

              break;

            case '(':
            case ')':
            case '{':
            case '}':
            case '[':
            case ']':
            case '+':
            case '-':
            case '*':
            case '/':
            case '^':
            case '~':
            case '#':
            case '.':
            case ',':
            case ';':
            case ':':
            case '=':
            case '@':
            case '|':
            case '$':
            case '?':
            case '!':
            case '"':
            case '<':
            case '>':
            case '`':
            case '\\':
            case '\'':
              if (str.length > 0) tokens.push(new SellToken(str, lineIdx, str_col));
              str = '';
              str_col = colIdx;

              if (ch == ':' && ch2 == '=') {
                ch = ":=";
                i++;
              } else if (ch == '^' && ch2 == '^') {
                ch = "^^";
                i++;
              } else if (ch == '\\' && ch2 == '\\') {
                ch = "\\\\";
                i++;
              } else if (ch == '-' && ch2 == '>') {
                ch = "->";
                i++;
              } else if (ch == '|' && ch2 == '-' && ch3 == '>') {
                ch = "|->";
                i += 2;
              } else if (ch == '<' && ch2 == '=') {
                ch = "<=";
                i++;
              } else if (ch == '>' && ch2 == '=') {
                ch = ">=";
                i++;
              } else if (ch == '=' && ch2 == '=') {
                ch = "==";
                i++;
              } else if (ch == '!' && ch2 == '=') {
                ch = "!=";
                i++;
              } else if (ch == '.' && ch2 == '.' && ch3 == '.') {
                ch = "...";
                i += 2;
              } else if (ch == '`' && ch2 == '`' && ch3 == '`') {
                ch = "```";
                i += 2;
              }

              tokens.push(new SellToken(ch, lineIdx, str_col));
              str_col = colIdx;
              break;

            default:
              if (str.length == 0) str_col = colIdx;
              str += ch;
          }

          colIdx++;
        }

        if (str.length > 0) tokens.push(new SellToken(str, lineIdx, str_col)); //for(let i=0; i<tokens.length; i++) {
        //    console.log(tokens[i]);
        //}

        return tokens;
      }
    }, {
      key: "printTokenList",
      value: function printTokenList(tokens) {
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          console.log(token.line + ':' + token.col + ':' + token.str);
        }
      }
    }, {
      key: "randomInt",
      value: function randomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min) + min);
      }
    }, {
      key: "splitStringAndKeepDelimiters",
      value: function splitStringAndKeepDelimiters(s, del) {
        var tokens = Array();
        var tk = '';

        for (var i = 0; i < s.length; i++) {
          var match = true;
          var match_d = '';

          for (var j = 0; j < del.length; j++) {
            var d = del[j];
            match = true;
            if (i + d.length > s.length) match = false;else {
              for (var k = 0; k < d.length; k++) {
                if (s[i + k] != d[k]) {
                  match = false;
                  break;
                }
              }
            }

            if (match) {
              match_d = d;
              break;
            }
          }

          if (match) {
            if (tk.length > 0) {
              tokens.push(tk);
              tk = '';
            }

            tokens.push(match_d);
            i += match_d.length - 1;
          } else {
            tk += s[i];
          }
        }

        if (tk.length > 0) tokens.push(tk);
        return tokens;
      }
    }]);

    return Lexer;
  }(); // end of class Lexer

  var ParseText = /*#__PURE__*/function () {
    function ParseText(parent) {
      _classCallCheck(this, ParseText);

      this.p = parent;
    } // title = 
    //   { ID | "#" ID | MISC } "\n";


    _createClass(ParseText, [{
      key: "parseTitle",
      value: function parseTitle() {
        this.p.parseWhitespaces = true;
        var title = '';

        while (!this.p.is('§EOL') && !this.p.is('§END')) {
          if (this.p.isIdent()) {
            title += this.p.tk;
            this.p.next();
          } else if (this.p.is('#')) {
            this.p.next();

            if (this.p.isIdent()) {
              this.p.tk; // TODO: yet unused

              this.p.next();
            } else this.p.err("expected identifer after '#'");
          } else {
            title += this.p.charToHTML(this.p.tk);
            this.p.next();
          }
        }

        this.p.terminal('§EOL');
        this.p.parseWhitespaces = false;
        this.p.q.titleHtml = title;
      }
    }, {
      key: "endItemizeIfApplicable",
      value: function endItemizeIfApplicable() {
        if (this.p.isItemizeItem) this.p.q.html += '</li>';
        if (this.p.isItemize) this.p.q.html += '</ul>';
        this.p.isItemizeItem = false;
        this.p.isItemize = false;
      } // text = 
      //   { single_multiple_choice | itemize | inline_listing | listing
      //     | inline_math | im_input | ID | MISC };

    }, {
      key: "parseText",
      value: function parseText() {
        var parsingHint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        this.p.parseWhitespaces = true;

        while (!this.p.is('§END') && !this.p.is('§CODE_START')) {
          if (parsingHint && this.p.is("§EOL")) break; // end itemize, if applicable

          if (this.p.tk_col == 1 && !this.p.is('*')) this.endItemizeIfApplicable(); // parse

          if (this.p.is('§EOL') && this.p.singleMultipleChoiceFeedbackHTML.length > 0) {
            this.p.q.html += '&nbsp;&nbsp;' + this.p.singleMultipleChoiceFeedbackHTML;
            this.p.singleMultipleChoiceFeedbackHTML = '';
            this.p.q.html += ']§'; // end of single-multiple choice
          }

          if (this.p.is('§EOL') && this.p.isItemizeItem) {
            this.p.next();
            this.p.q.html += '</li>';
            this.p.isItemizeItem = false;
          } else if (this.p.tk_col == 1 && this.p.is("[")) this.parseSingleMultipleChoice(false
          /*multiple choice*/
          );else if (this.p.tk_col == 1 && this.p.is("(")) this.parseSingleMultipleChoice(true
          /*single choice*/
          );else if (this.p.tk_col == 1 && this.p.is('*')) this.parseItemize();else if (this.p.is('`')) this.p.q.html += this.parseInlineListing();else if (this.p.is('```')) this.p.q.html += this.parseListing();else if (this.p.is('$')) this.p.imParser.parseInlineMath();else if (this.p.is('#')) this.p.q.html += this.p.imInputParser.parseIM_Input();else if (this.p.isIdent()) {
            // "__"/"_" are used to stard and end bold/italic font.
            // Tokens include underscores in general for most part of SELL, especially the code part.
            // Splitting is done here for text.
            var tokens = Lexer.splitStringAndKeepDelimiters(this.p.tk, ["__", "_"]);
            this.p.next();

            for (var i = 0; i < tokens.length; i++) {
              if (tokens[i] === '_') {
                this.p.isItalicFont = !this.p.isItalicFont;
                this.p.q.html += this.p.isItalicFont ? '<i>' : '</i>';
              } else if (tokens[i] === '__') {
                this.p.isBoldFont = !this.p.isBoldFont;
                this.p.q.html += this.p.isBoldFont ? '<b>' : '</b>';
              } else this.p.q.html += tokens[i];
            }
          } else {
            this.p.q.html += this.p.charToHTML(this.p.tk);
            this.p.next();
          }
        }

        this.p.parseWhitespaces = false;
        this.endItemizeIfApplicable();
      } // itemize =
      //   "*";

    }, {
      key: "parseItemize",
      value: function parseItemize() {
        this.p.terminal('*');

        if (this.p.isItemize == false) {
          this.p.q.html += '<ul>';
        }

        this.p.isItemize = true;
        this.p.isItemizeItem = true;
        this.p.q.html += '<li>';
      } // single_multiple_choice =
      //     "(" ("x"|expr) ")"
      //   | "[" ("x"|expr) "]";

    }, {
      key: "parseSingleMultipleChoice",
      value: function parseSingleMultipleChoice(isSingleChoice) {
        this.p.parseWhitespaces = false;
        var correct = false;
        if (isSingleChoice) this.p.terminal("(");else this.p.terminal("[");

        if (this.p.is("x")) {
          this.p.next();
          correct = true;
        } else if (!this.p.is("]") && !this.p.is(")") && !this.p.is(' ')) {
          this.p.codeParser.parseExpr();
          var v = this.p.q.stack.pop();
          if (v.type != symtype.T_BOOL) this.p.err("expression must be boolean");
          correct = v.value;
        }

        if (isSingleChoice) this.p.terminal(")");else this.p.terminal("]");
        this.p.parseWhitespaces = true;
        var prefix = isSingleChoice ? "_sc_" : "_mc_";
        var sym = new SellSymbol(symtype.T_BOOL, correct);
        var symId = prefix + this.p.createUniqueID();
        this.p.q.symbols[symId] = sym;
        this.p.q.solutionSymbols[symId] = sym;
        var input = new SellInput();
        input.htmlElementId = "sellquiz_input_" + symId;
        input.solutionVariableId = symId;
        input.htmlElementId_feedback = "sellquiz_feedback_" + symId;
        input.htmlElementInputType = SellInputElementType.CHECKBOX;
        this.p.q.inputs.push(input);
        var inputType = isSingleChoice ? "radio" : "checkbox";
        var checked = "";
        this.p.q.html += '\n§[';
        this.p.q.html += '<input id="' + input.htmlElementId + '" type="' + inputType + '" name="sell_input" ' + checked + '/>&nbsp;';
        this.p.singleMultipleChoiceFeedbackHTML = '&nbsp;<span id="' + input.htmlElementId_feedback + '"></span>\n';
      } // inline_listing =
      //   "`" { MISC } "`";

    }, {
      key: "parseInlineListing",
      value: function parseInlineListing() {
        var html = '';
        this.p.terminal('`');
        html += '<code class="text-primary">';

        while (!this.p.is('`') && !this.p.is('§END')) {
          html += this.p.tk;
          this.p.next();
        }

        this.p.terminal('`');
        html += '</code>';
        return html;
      } // listing =
      //   "```" { MISC } "```";

    }, {
      key: "parseListing",
      value: function parseListing() {
        var code = '';
        this.p.terminal('```');

        while (!this.p.is('```') && !this.p.is('§END')) {
          if (this.p.is("§EOL")) {
            code += '\n';
            this.p.next();

            while (this.p.is(" ")) {
              code += '&nbsp;';
              this.p.next();
            }
          } else if (this.p.is("\t")) {
            code += '&nbsp;&nbsp;&nbsp;&nbsp;';
            this.p.next();
          } else {
            code += this.p.tk;
            this.p.next();
          }
        }

        code = code.replaceAll('<', '&lt;');
        code = code.replaceAll('>', '&gt;');
        code = code.replaceAll('\n', '<br/>');
        this.p.terminal('```');
        var html = '';
        html += '<hr class="mt-2 mb-0"/>';
        html += '<code class="text-primary">';
        html += code;
        html += '</code>';
        html += '<hr class="mt-0 mb-0"/>';
        return html;
      }
    }]);

    return ParseText;
  }();

  var SellLinAlg = /*#__PURE__*/function () {
    function SellLinAlg() {
      _classCallCheck(this, SellLinAlg);
    }

    _createClass(SellLinAlg, null, [{
      key: "mat_idx",
      value: function mat_idx(m, n, i, j) {
        return i * n + j;
      }
    }, {
      key: "mat_get_row_count",
      value: function mat_get_row_count(mathjs_matrix) {
        return mathjs_matrix.size()[0];
      }
    }, {
      key: "mat_get_col_count",
      value: function mat_get_col_count(mathjs_matrix) {
        return mathjs_matrix.size()[1];
      }
    }, {
      key: "mat_get_element_value",
      value: function mat_get_element_value(mathjs_matrix, i, j) {
        return mathjs_matrix.subset(math__namespace.index(i, j));
      }
    }, {
      key: "mat_submatrix",
      value: function mat_submatrix(mathjs_matrix, first_row, last_row, first_col, last_col) {
        var m = mathjs_matrix.size()[0];
        var n = mathjs_matrix.size()[1];
        if (last_row == -1) // -1 := last row
          last_row = m - 1;
        if (last_col == -1) // -1 := last col
          last_col = n - 1;
        if (first_row > last_row || first_col > last_col) return null;
        if (first_row < 0 || first_col < 0 || first_row >= m || first_col >= n) return null;
        if (last_row < 0 || last_col < 0 || last_row >= m || last_col >= n) return null;
        var resM = last_row - first_row + 1;
        var resN = last_col - first_col + 1;
        var res = math__namespace.zeros(resM, resN);

        for (var i = first_row; i <= last_row; i++) {
          for (var j = first_col; j <= last_col; j++) {
            var v = mathjs_matrix.subset(math__namespace.index(i, j));
            res = this.mat_set_element(res, i - first_row, j - first_col, v);
          }
        }

        return res;
      }
    }, {
      key: "mat_rank",
      value: function mat_rank(mathjs_matrix) {
        // implementation based on https://cp-algorithms.com/linear_algebra/rank-matrix.html
        var epsilon = 1e-12;
        var m = mathjs_matrix.size()[0];
        var n = mathjs_matrix.size()[1];
        var v = [];

        for (var i = 0; i < m; i++) {
          for (var j = 0; j < n; j++) {
            v.push(mathjs_matrix.subset(math__namespace.index(i, j)));
          }
        }

        var rank = 0;
        var row_selected = [];

        for (var k = 0; k < n; k++) {
          row_selected.push(false);
        }

        for (var _i = 0; _i < m; _i++) {
          var _j = void 0;

          for (_j = 0; _j < n; _j++) {
            if (!row_selected[_j] && Math.abs(v[this.mat_idx(m, n, _i, _j)]) > epsilon) {
              break;
            }
          }

          if (_j != n) {
            rank++;
            row_selected[_j] = true;

            for (var p = _i + 1; p < m; p++) {
              v[this.mat_idx(m, n, p, _j)] /= v[this.mat_idx(m, n, _i, _j)];
            }

            for (var _k = 0; _k < n; _k++) {
              if (_k != _j && Math.abs(v[this.mat_idx(m, n, _i, _k)]) > epsilon) {
                for (var _p = _i + 1; _p < m; _p++) {
                  v[this.mat_idx(m, n, _p, _k)] -= v[this.mat_idx(m, n, _p, _j)] * v[this.mat_idx(m, n, _i, _k)];
                }
              }
            }
          }
        }

        return rank;
      }
    }, {
      key: "mat_is_symmetric",
      value: function mat_is_symmetric(mathjs_matrix) {
        var m = mathjs_matrix.size()[0];
        var n = mathjs_matrix.size()[1];
        if (m != n) return false;

        for (var i = 0; i < n; i++) {
          for (var j = i + 1; j < n; j++) {
            var a = mathjs_matrix.subset(math__namespace.index(i, j));
            var b = mathjs_matrix.subset(math__namespace.index(j, i));
            if (math__namespace.abs(a - b) > 1e-14) return false;
          }
        }

        return true;
      }
    }, {
      key: "mat_triu",
      value: function mat_triu(mathjs_matrix) {
        var m = mathjs_matrix.size()[0];
        var n = mathjs_matrix.size()[1];
        var res = math__namespace.zeros(m, n);

        for (var i = 0; i < m; i++) {
          for (var j = 0; j < n; j++) {
            var v = mathjs_matrix.subset(math__namespace.index(i, j));
            if (j < i) v = 0;
            res = res.subset(math__namespace.index(i, j), v);
          }
        }

        return res;
      }
    }, {
      key: "mat_norm2",
      value: function mat_norm2(mathjs_matrix) {
        var m = mathjs_matrix.size()[0];
        var n = mathjs_matrix.size()[1];
        var res = 0.0;

        for (var i = 0; i < m; i++) {
          for (var j = 0; j < n; j++) {
            var e_ij = mathjs_matrix.subset(math__namespace.index(i, j));
            res += e_ij * e_ij;
          }
        }

        return math__namespace.sqrt(res);
      }
    }, {
      key: "mat_vecdot",
      value: function mat_vecdot(mathjs_matrix_1, mathjs_matrix_2) {
        var m1 = mathjs_matrix_1.size()[0];
        var n1 = mathjs_matrix_1.size()[1];
        var m2 = mathjs_matrix_2.size()[0];
        var n2 = mathjs_matrix_2.size()[1];
        if (n1 != 1 || n2 != 1 || m1 != m2) sellassert(false, "mat_vecdot(..): invalid input");
        var res = 0.0;

        for (var i = 0; i < m1; i++) {
          res += mathjs_matrix_1.subset(math__namespace.index(i, 0)) * mathjs_matrix_2.subset(math__namespace.index(i, 0));
        }

        return res;
      }
    }, {
      key: "mat_veccross",
      value: function mat_veccross(mathjs_matrix_1, mathjs_matrix_2) {
        var m1 = mathjs_matrix_1.size()[0];
        var n1 = mathjs_matrix_1.size()[1];
        var m2 = mathjs_matrix_2.size()[0];
        var n2 = mathjs_matrix_2.size()[1];
        if (n1 != 1 || n2 != 1 || m1 != 3 || m2 != 3) sellassert(false, "mat_veccross(..): invalid input");
        var u1 = this.mat_get_element_value(mathjs_matrix_1, 0, 0);
        var u2 = this.mat_get_element_value(mathjs_matrix_1, 1, 0);
        var u3 = this.mat_get_element_value(mathjs_matrix_1, 2, 0);
        var v1 = this.mat_get_element_value(mathjs_matrix_2, 0, 0);
        var v2 = this.mat_get_element_value(mathjs_matrix_2, 1, 0);
        var v3 = this.mat_get_element_value(mathjs_matrix_2, 2, 0);
        var res = math__namespace.zeros(3, 1);
        res = res.subset(math__namespace.index(0, 0), u2 * v3 - u3 * v2);
        res = res.subset(math__namespace.index(1, 0), u3 * v1 - u1 * v3);
        res = res.subset(math__namespace.index(2, 0), u1 * v2 - u2 * v1);
        return res;
      }
    }, {
      key: "mat_is_row_zero",
      value: function mat_is_row_zero(mat_v, m, n, i) {
        var epsilon = 1e-12;

        for (var j = 0; j < n; j++) {
          if (Math.abs(mat_v[this.mat_idx(m, n, i, j)]) > epsilon) return false;
        }

        return true;
      }
    }, {
      key: "mat_is_zero",
      value: function mat_is_zero(mathjs_matrix) {
        var EPSILON = 1e-12;
        var m = mathjs_matrix.size()[0];
        var n = mathjs_matrix.size()[1];

        for (var i = 0; i < m; i++) {
          for (var j = 0; j < n; j++) {
            var v = mathjs_matrix.subset(math__namespace.index(i, j));
            if (Math.abs(v) > EPSILON) return false;
          }
        }

        return true;
      }
    }, {
      key: "linsolve",
      value: function linsolve(mathjs_matrix_A, mathjs_vector_b) {
        mathjs_matrix_A.size()[0];
        mathjs_matrix_A.size()[1];
        return math__namespace.lusolve(mathjs_matrix_A.clone(), mathjs_vector_b.clone());
      }
    }, {
      key: "mat_kernel",
      value: function mat_kernel(mathjs_matrix) {
        // TODO: better use SVD; but yet no suitable implementation in JavaScript found!
        //mathjs_matrix = math.matrix([[2, 1, -1],[0, 2, 3]]); // TODO: remove test!!!!!
        //mathjs_matrix = math.matrix([[1, 2, 3],[0, 4, 5],[0, 0, 6]]); // TODO: remove test!!!!!
        var lup = math__namespace.lup(mathjs_matrix);
        var u = lup["U"];
        var m = u.size()[0];
        var n = u.size()[1];
        var v = [];

        for (var i = 0; i < m; i++) {
          for (var j = 0; j < n; j++) {
            v.push(u.subset(math__namespace.index(i, j)));
          }
        } // get number of nonzero rows


        var nz;

        for (nz = 0; nz < m; nz++) {
          if (this.mat_is_row_zero(v, m, n, nz)) break;
        } //alert(v)
        //alert(nz)
        // set upper-right to zero


        for (var _j2 = nz - 1; _j2 >= 1; _j2--) {
          for (var _i2 = _j2 - 1; _i2 >= 0; _i2--) {
            //alert(i + ' ' + j)
            var f = v[this.mat_idx(m, n, _i2, _j2)] / v[this.mat_idx(m, n, _j2, _j2)]; //alert(f)

            for (var k = 0; k < n; k++) {
              v[this.mat_idx(m, n, _i2, k)] -= f * v[this.mat_idx(m, n, _j2, k)];
            }
          }
        } //alert(v)
        // normalize := divide by pivot elements


        for (var _i3 = 0; _i3 < nz; _i3++) {
          var p = v[this.mat_idx(m, n, _i3, _i3)];

          for (var _j3 = 0; _j3 < n; _j3++) {
            v[this.mat_idx(m, n, _i3, _j3)] /= p;
          }
        } //alert(v)
        // resulting matrix: ker-vector per column


        var dest_m = n;
        var dest_n = n - nz;
        var dest = [];

        for (var _k2 = 0; _k2 < dest_m * dest_n; _k2++) {
          dest.push(0.0);
        }

        for (var _k3 = 0; _k3 < dest_n; _k3++) {
          dest[this.mat_idx(dest_m, dest_n, dest_m - 1 - _k3, dest_n - 1 - _k3)] = -1;
        } // "-1 - trick"


        for (var _i4 = 0; _i4 < nz; _i4++) {
          for (var _j4 = 0; _j4 < dest_n; _j4++) {
            dest[this.mat_idx(dest_m, dest_n, _i4, _j4)] = v[this.mat_idx(m, n, _i4, _j4 + nz)];
          }
        }

        var dest_mathjs = math__namespace.zeros(dest_m, dest_n);

        for (var _i5 = 0; _i5 < dest_m; _i5++) {
          for (var _j5 = 0; _j5 < dest_n; _j5++) {
            dest_mathjs = dest_mathjs.subset(math__namespace.index(_i5, _j5), dest[this.mat_idx(dest_m, dest_n, _i5, _j5)]);
          }
        }

        return dest;
      }
    }, {
      key: "mat_set_element",
      value: function mat_set_element(mathjs_matrix, i, j, value) {
        var m = mathjs_matrix.size()[0];
        var n = mathjs_matrix.size()[1];
        if (i < 0 || i >= m) return null;
        if (j < 0 || j >= n) return null;
        mathjs_matrix = mathjs_matrix.subset(math__namespace.index(i, j), value);
        return mathjs_matrix;
      }
    }, {
      key: "mat_mod",
      value: function mat_mod(mathjs_matrix, op2) {
        var m = mathjs_matrix.size()[0];
        var n = mathjs_matrix.size()[1];
        var dest = math__namespace.zeros(m, n);

        for (var i = 0; i < m; i++) {
          for (var j = 0; j < n; j++) {
            var v = Math.round(mathjs_matrix.subset(math__namespace.index(i, j)));
            v = math__namespace.mod(v, op2);
            dest = dest.subset(math__namespace.index(i, j), v);
          }
        }

        return dest;
      }
    }, {
      key: "mat_compare_numerically",
      value: function mat_compare_numerically(mathjs_matrix_a, mathjs_matrix_b) {
        var EPSILON = 1e-12;
        var m_a = mathjs_matrix_a.size()[0];
        var n_a = mathjs_matrix_a.size()[1];
        var m_b = mathjs_matrix_b.size()[0];
        var n_b = mathjs_matrix_b.size()[1];
        if (m_a != m_b && n_a != n_b) return false;

        for (var i = 0; i < m_a; i++) {
          for (var j = 0; j < n_a; j++) {
            var va = mathjs_matrix_a.subset(math__namespace.index(i, j));
            var vb = mathjs_matrix_b.subset(math__namespace.index(i, j));
            if (Math.abs(va - vb) > EPSILON) return false;
          }
        }

        return true;
      }
    }, {
      key: "mat_compare_numerically_except_scaling_factor",
      value: function mat_compare_numerically_except_scaling_factor(mathjs_matrix_a, mathjs_matrix_b) {
        var EPSILON = 1e-12;
        var m_a = mathjs_matrix_a.size()[0];
        var n_a = mathjs_matrix_a.size()[1];
        var m_b = mathjs_matrix_b.size()[0];
        var n_b = mathjs_matrix_b.size()[1];
        if (m_a != m_b && n_a != n_b) return false;
        var initial_f = true;
        var f = 1.0;

        for (var i = 0; i < m_a; i++) {
          for (var j = 0; j < n_a; j++) {
            var va = mathjs_matrix_a.subset(math__namespace.index(i, j));
            var vb = mathjs_matrix_b.subset(math__namespace.index(i, j));

            if (Math.abs(va * f - vb) > EPSILON) {
              if (initial_f) {
                initial_f = false;
                if (Math.abs(va) < EPSILON || Math.abs(vb) < EPSILON) return false;
                f = vb / va;
              } else {
                return false;
              }
            }
          }
        }

        return true;
      }
    }]);

    return SellLinAlg;
  }(); // end of class SellLinAlg

  var SellSymTermElement = function SellSymTermElement(type, v) {
    _classCallCheck(this, SellSymTermElement);

    this.type = type;
    this.v = v;
    this.deriv = null;
  };
  var SellSymTerm = /*#__PURE__*/function () {
    function SellSymTerm() {
      var symbolIDs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, SellSymTerm);

      this.symbolIDs = symbolIDs;
      this.stack = [];
      this.state = ""; // e.g. "syntax-error"

      this.contains_forbidden_ode_subtree = false;
    }

    _createClass(SellSymTerm, [{
      key: "clear",
      value: function clear() {
        this.stack = [];
      }
    }, {
      key: "importTerm",
      value: function importTerm(str) {
        var n = math__namespace.parse(str);
        return this.importMathJsTermJsRecursively(n);
      }
    }, {
      key: "importMathJsTermJsRecursively",
      value: function importMathJsTermJsRecursively(node) {
        // TODO: this is incomplete...
        switch (node.type) {
          case "ConstantNode":
            this.pushConstant(node.value);
            break;

          case "SymbolNode":
            this.pushVariable(node.name);
            break;

          case "OperatorNode":
          case "ParenthesisNode":
            while (node.type == "ParenthesisNode") {
              node = node.content;
            }

            if (node.fn == "unaryMinus") {
              if (this.importMathJsTermJsRecursively(node.args[0]) == false) return false;
              this.pushUnaryOperation("-");
            } else if (node.op == "+" || node.op == "-" || node.op == "*" || node.op == "/" || node.op == "^") {
              if (this.importMathJsTermJsRecursively(node.args[0]) == false) return false;
              if (this.importMathJsTermJsRecursively(node.args[1]) == false) return false;
              this.pushBinaryOperation(node.op);
            } else {
              console.log("warning: SellSymTerm::importMathJsTermJsRecursively(..): unknown/unimplemented operation " + node.op);
              return false;
            }

            break;

          case "FunctionNode":
            if (node.name == "exp" || node.name == "sin" || node.name == "cos" || node.name == "sqrt") {
              if (this.importMathJsTermJsRecursively(node.args[0]) == false) return false;
              this.pushUnaryFunction(node.name);
            } else {
              console.log("warning: SellSymTerm::importMathJsTermJsRecursively(..): unknown/unimplemented function " + node.name);
              return false;
            }

            break;

          default:
            console.log("warning: SellSymTerm::importMathJsTermJsRecursively(..): unknown/unimplemented node type " + node.type);
            return false;
        }

        return true;
      }
    }, {
      key: "pushVariable",
      value: function pushVariable(id) {
        this.stack.push(new SellSymTermElement("var", id));
      }
    }, {
      key: "pushOdeFunction",
      value: function pushOdeFunction(f) {
        this.stack.push(new SellSymTermElement("ode_fun", f));
      }
    }, {
      key: "pushConstant",
      value: function pushConstant(v) {
        v = parseFloat(v);
        this.stack.push(new SellSymTermElement("const", v));
      }
    }, {
      key: "pushSymbolicTerm",
      value: function pushSymbolicTerm(st) {
        if (st.stack.length == 0) this.stack.push(new SellSymTermElement("const", 0));else this.stack.push(st.stack[0]);
      }
    }, {
      key: "pushUnaryFunction",
      value: function pushUnaryFunction(name) {
        var param = this.stack.pop();
        this.stack.push(new SellSymTermElement("fct1", [name, param]));
      }
    }, {
      key: "pushBinaryFunction",
      value: function pushBinaryFunction(name) {
        var param2 = this.stack.pop();
        var param1 = this.stack.pop();
        this.stack.push(new SellSymTermElement("fct2", [name, param1, param2]));
      }
    }, {
      key: "pushDiff",
      value: function pushDiff() {
        // TODO: must check, if following variables are "OK"...
        var diffVar = this.stack.pop();
        var diffFct = this.stack.pop();
        var term = new SellSymTerm();
        term.symbolIDs = this.symbolIDs; // TODO: copy?

        term.stack.push(diffFct); // TODO: copy?

        var diff = term.derivate(diffVar.v);
        this.pushSymbolicTerm(diff);
      }
    }, {
      key: "pushUnaryOperation",
      value: function pushUnaryOperation(type) {
        var op = this.stack.pop();
        this.stack.push(new SellSymTermElement("uniop", [type, op]));
      }
    }, {
      key: "pushBinaryOperation",
      value: function pushBinaryOperation(type) {
        type = type.replace("add", "+").replace("sub", "-").replace("mul", "*").replace("div", "/").replace("pow", "^");
        var op2 = this.stack.pop();
        var op1 = this.stack.pop();

        if (op1.type == "const" && op2.type == "const") {
          var res;
          res = 0;

          switch (type) {
            case "+":
              res = op1.v + op2.v;
              break;

            case "-":
              res = op1.v - op2.v;
              break;

            case "*":
              res = op1.v * op2.v;
              break;

            case "/":
              res = op1.v / op2.v;
              break;

            case "^":
              res = math__namespace.pow(op1.v, op2.v);
              break;

            default:
              alert("unimplemented: SellSymTerm:pushBinaryOperation(..): operator " + type);
          }

          this.stack.push(new SellSymTermElement("const", res));
        } else {
          this.stack.push(new SellSymTermElement("binop", [type, op1, op2]));
        }
      }
    }, {
      key: "appendVariableSet",
      value: function appendVariableSet(v, v_new) {
        for (var i = 0; i < v_new.length; i++) {
          var found = false;

          for (var j = 0; j < v.length; j++) {
            if (v_new[i] === v[j]) {
              found = true;
              break;
            }
          }

          if (found == false) {
            v.push(v_new[i]);
          }
        }
      }
    }, {
      key: "getVariables",
      value: function getVariables() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var v = [],
            v1,
            v2;

        if (element == null) {
          element = this.stack[0];
        }

        switch (element.type) {
          case "var":
            //v.push(element.v);
            this.appendVariableSet(v, [element.v]);
            break;

          case "const":
            break;

          case "uniop":
            v1 = this.getVariables(element.v[1]);
            this.appendVariableSet(v, v1);
            break;

          case "binop":
            v1 = this.getVariables(element.v[1]);
            this.appendVariableSet(v, v1);
            v2 = this.getVariables(element.v[2]);
            this.appendVariableSet(v, v2);
            break;

          case "ode_fun":
            this.appendVariableSet(v, [element.v]); //element.mathsymbol_ids // TODO: mathsymbol_ids relevant??

            break;

          case "fct1":
            v1 = this.getVariables(element.v[1]);
            this.appendVariableSet(v, v1);
            break;

          case "fct2":
            v1 = this.getVariables(element.v[1]);
            this.appendVariableSet(v, v1);
            v2 = this.getVariables(element.v[2]);
            this.appendVariableSet(v, v2);
            break;

          default:
            alert("unimplemented: SellSymTerm:getVariables(..): " + element.type);
        }

        return v;
      }
    }, {
      key: "getOdeOrder",
      value: function getOdeOrder() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        // TODO: does not work for PDE!!
        var o = 0;

        if (element == null) {
          element = this.stack[0];
        }

        switch (element.type) {
          case "uniop":
            o = math__namespace.max(o, this.getOdeOrder(element.v[1]));
            break;

          case "binop":
            o = math__namespace.max(o, this.getOdeOrder(element.v[1]));
            o = math__namespace.max(o, this.getOdeOrder(element.v[2]));
            break;

          case "fct2":
            if (element.v[0] == "diff_ode") o = math__namespace.max(o, 1);else if (element.v[0] == "diff2_ode") o = math__namespace.max(o, 2);
            break;
        }

        return o;
      }
    }, {
      key: "optimizeOdeConstants",
      value: function optimizeOdeConstants() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var e, e1, e2;

        if (element == null) {
          element = this.stack[0];
        }

        switch (element.type) {
          case "var":
            break;

          case "uniop":
            this.optimizeOdeConstants(element.v[1]);
            e = element.v[1];

            if (e.type === "var" && e.v.startsWith("C")) {
              element.type = "var";
              element.v = e.v;
            }

            break;

          case "binop":
            this.optimizeOdeConstants(element.v[1]);
            this.optimizeOdeConstants(element.v[2]);
            e1 = element.v[1];
            e2 = element.v[2];

            if (e1.type === "var" && e1.v.startsWith("C") && e2.type === "const") {
              element.type = "var";
              element.v = e1.v;
            } else if (e2.type === "var" && e2.v.startsWith("C") && e1.type === "const") {
              element.type = "var";
              element.v = e2.v;
            }

            break;

          case "fct1":
            this.optimizeOdeConstants(element.v[1]);
            e = element.v[1];

            if (e.type === "var" && e.v.startsWith("C")) {
              element.type = "var";
              element.v = e.v;
            }

            break;
        }
      }
    }, {
      key: "searchForForbiddenODESecondOrderSubterms",
      value: function searchForForbiddenODESecondOrderSubterms() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var v = [],
            v1,
            v2;

        if (element == null) {
          element = this.stack[0];
        }

        switch (element.type) {
          case "var":
            //v.push(element.v);
            this.appendVariableSet(v, [element.v]);
            break;

          case "const":
            break;

          case "uniop":
            v1 = this.searchForForbiddenODESecondOrderSubterms(element.v[1]);
            this.appendVariableSet(v, v1);
            break;

          case "binop":
            v1 = this.searchForForbiddenODESecondOrderSubterms(element.v[1]);
            this.appendVariableSet(v, v1);
            v2 = this.searchForForbiddenODESecondOrderSubterms(element.v[2]);
            this.appendVariableSet(v, v2);
            break;

          case "ode_fun":
            this.appendVariableSet(v, [element.v]); //element.mathsymbol_ids // TODO: mathsymbol_ids relevant??

            break;

          case "fct1":
            v1 = this.searchForForbiddenODESecondOrderSubterms(element.v[1]);
            this.appendVariableSet(v, v1);
            break;

          case "fct2":
            v1 = this.searchForForbiddenODESecondOrderSubterms(element.v[1]);
            this.appendVariableSet(v, v1);
            v2 = this.searchForForbiddenODESecondOrderSubterms(element.v[2]);
            this.appendVariableSet(v, v2);
            break;

          default:
            alert("unimplemented: SellSymTerm:searchForForbiddenODESecondOrderSubterms(..): " + element.type);
        }

        console.log("TEST:");
        console.log(v);

        if (v.length == 2) {
          this.contains_forbidden_ode_subtree = true;

          for (var i = 0; i < v.length; i++) {
            if (v[i].startsWith("C") == false) this.contains_forbidden_ode_subtree = false;
          }
        }

        return v;
      }
    }, {
      key: "getOperator",
      value: function getOperator(element) {
        var op = "";
        if (element.type == "uniop" || element.type == "binop") op = element.v[0];
        return op;
      }
    }, {
      key: "getOperatorPrecedence",
      value: function getOperatorPrecedence(op) {
        var p = 0;

        switch (op) {
          case "+":
            p = 10;
            break;

          case "-":
            p = 10;
            break;
          // TODO: this was 11

          case "*":
            p = 20;
            break;

          case "/":
            p = 20;
            break;
          // TODO: this was 21

          case "^":
            p = 30;
            break;

          case "":
            p = 99;
            break;

          default:
            alert("unimplemented: SellSymTerm:getOperatorPrecedence(..): op=" + op);
        }

        return p;
      }
    }, {
      key: "toString",
      value: function toString() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var s = "";
        var root = false;

        if (element == null) {
          root = true;
          element = this.stack[0];
        }

        var name, arg, arg1, arg2;

        switch (element.type) {
          case "var":
            s = element.v;
            break;

          case "const":
            s = element.v.toString();
            if (math__namespace.abs(element.v - 3.141592653589793) < 1e-12) s = "pi";
            break;

          case "uniop":
            s = element.v[0] + this.toString(element.v[1]);
            if (element.v[1].type == 'uniop') s = "(" + s + ")";
            break;

          case "ode_fun":
            /*if(element.v[0].type === "function")
                s = element.value.toString();
            else*/
            s = element.v.id + "(" + element.v.mathsymbol_ids[0] + ")";
            break;

          case "binop":
            var c1 = this.toString(element.v[1]);
            var c2 = this.toString(element.v[2]);
            var op = element.v[0];
            var op_precedence = this.getOperatorPrecedence(op);
            var op1 = this.getOperator(element.v[1]);
            var op1_precedence = this.getOperatorPrecedence(op1);
            var op2 = this.getOperator(element.v[2]);
            var op2_precedence = this.getOperatorPrecedence(op2);
            if (op1_precedence < op_precedence) c1 = "(" + c1 + ")";else if (op === "/") c1 = "(" + c1 + ")";
            if (op2_precedence < op_precedence
            /*|| op2.type == 'uniop'*/
            ) c2 = "(" + c2 + ")";else if (c2.startsWith("-")) c2 = "(" + c2 + ")";else if (op === "-" || op === "/") {
              if (element.v[2].type !== "const") c2 = "(" + c2 + ")";
            }
            s = c1 + op + c2;
            break;

          case "fct1":
            name = element.v[0];
            arg = this.toString(element.v[1]);
            if (name === "exp" && arg.length < 5) s = "e^(" + arg + ")";else s = name + "(" + arg + ")";
            break;

          case "fct2":
            name = element.v[0];

            if (name === "diff_ode") {
              // TODO: should now work, since we have "diff2_ode"

              /*// TODO: this is yet only statically implemented for second order, as well as nested differentials with the same derivative variable
              //alert(element.v.length)
              if(element.v[1].v.type == "function")
                  s = element.v[1].v.value.stack[0].v[1].v.id + "''(" + element.v[2].v + ")";
              else*/
              s = element.v[1].v.id + "'(" + element.v[2].v + ")";
            } else if (name === "diff2_ode") {
              s = element.v[1].v.id + "''(" + element.v[2].v + ")";
            } else {
              arg1 = this.toString(element.v[1]);
              arg2 = this.toString(element.v[2]);
              s = name + "(" + arg1 + ", " + arg2 + ")";
            }

            break;

          default:
            alert("unimplemented: SellSymTerm:toString(..): " + element.type);
        }

        if (root && s.startsWith("(")) {
          s = s; //  s.substr(1, s.length-2); TODO
        }

        return s;
      }
    }, {
      key: "derivate",
      value: function derivate(variable
      /*id*/
      ) {
        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var u, v, op, name, p1;
        var isRoot = element == null;
        if (isRoot) element = this.stack[0];

        switch (element.type) {
          case "var":
            element.deriv = new SellSymTermElement("const", element.v == variable ? 1 : 0);
            break;

          case "const":
            element.deriv = new SellSymTermElement("const", 0);
            break;

          case "uniop":
            u = element.v[1];
            this.derivate(variable, u);
            op = element.v[0];

            switch (op) {
              case "-":
                // f = - u
                // f' = - u'
                element.deriv = new SellSymTermElement("uniop", [op, u.deriv]);
                break;

              default:
                alert("unimplemented: SellSymTerm:derivate(..): uniop: " + op);
            }

            break;

          case "binop":
            u = element.v[1];
            this.derivate(variable, u);
            v = element.v[2];
            this.derivate(variable, v);
            op = element.v[0];

            switch (op) {
              case "+":
              case "-":
                // f  = u + v
                // f' = u' + v'
                element.deriv = new SellSymTermElement("binop", [op, u.deriv, v.deriv]);
                break;

              case "*":
                // f  = u * v
                // f' = u'*v + v'*u
                element.deriv = new SellSymTermElement("binop", ["+", new SellSymTermElement("binop", ["*", u.deriv, v]), new SellSymTermElement("binop", ["*", v.deriv, u])]);
                break;

              case "/":
                // f  = u / v
                // f' = (u'*v - v'*u) / v^2
                element.deriv = new SellSymTermElement("binop", ["/", new SellSymTermElement("binop", ["-", new SellSymTermElement("binop", ["*", u.deriv, v]), new SellSymTermElement("binop", ["*", v.deriv, u])]), new SellSymTermElement("binop", ["*", v, v])]);
                break;

              case "^":
                // f  = u^v (assuming v is const)
                // f' = u' * v * u^(v-1)
                if (v.type !== "const") alert("unimplemented: SellSymTerm:derivate(..): derivation of u^v with v != const");
                element.deriv = new SellSymTermElement("binop", ["*", u.deriv, new SellSymTermElement("binop", ["*", v, new SellSymTermElement("binop", ["^", u, new SellSymTermElement("binop", ["-", v, new SellSymTermElement("const", 1)])])])]);
                break;

              default:
                alert("unimplemented: SellSymTerm:derivate(..): binop: " + op);
            }

            break;

          case "fct1":
            name = element.v[0];
            p1 = element.v[1];
            this.derivate(variable, p1);

            switch (name) {
              case "sin":
                // f = sin(p1)
                // f' = p1' * cos(p1)
                element.deriv = new SellSymTermElement("binop", ["*", p1.deriv, new SellSymTermElement("fct1", ["cos", p1])]);
                break;

              case "cos":
                // f = cos(p1)
                // f' = - p1' * sin(p1)
                element.deriv = new SellSymTermElement("uniop", ["-", new SellSymTermElement("binop", ["*", p1.deriv, new SellSymTermElement("fct1", ["sin", p1])])]);
                break;

              case "exp":
                // f  = exp(p1)
                // f' = p1' * exp(p1)
                element.deriv = new SellSymTermElement("binop", ["*", p1.deriv, new SellSymTermElement("fct1", ["exp", p1])]);
                break;

              case "sqrt":
                // f  = sqrt(p1) = p1^(0.5)
                // f' = p1' / (2*sqrt(p1))
                element.deriv = new SellSymTermElement("binop", ["/", p1.deriv, new SellSymTermElement("binop", ["*", new SellSymTermElement("const", 2), new SellSymTermElement("fct1", ["sqrt", p1])])]);
                break;

              default:
                alert("unimplemented: SellSymTerm:derivate(..): fct1: " + name);
            }

            break;

          default:
            alert("unimplemented: SellSymTerm:derivate(..): " + element.type);
        }

        if (isRoot) {
          var t = new SellSymTerm();
          t.symbolIDs = this.symbolIDs;
          t.stack = [this.stack[0].deriv];
          t.optimize();
          return t;
        } else return null;
      }
    }, {
      key: "eval",
      value: function _eval(var_values
      /*dict*/
      ) {
        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var res, u, v, op, name, param;
        res = 0;
        if (element == null) element = this.stack[0];

        switch (element.type) {
          case "var":
            if (element.v in var_values) {
              res = parseFloat(var_values[element.v]);
            } else {
              alert("SellSymTerm:eval(..): variable " + element.v + " has no value!");
              return 0;
            }

            break;

          case "const":
            res = element.v;
            break;

          case "uniop":
            u = this.eval(var_values, element.v[1]);
            op = element.v[0];

            switch (op) {
              case "-":
                res = -u;
                break;

              default:
                alert("unimplemented: SellSymTerm:eval(..): uniop: " + op);
            }

            break;

          case "binop":
            u = this.eval(var_values, element.v[1]);
            v = this.eval(var_values, element.v[2]);
            op = element.v[0];

            switch (op) {
              case "+":
                res = u + v;
                break;

              case "-":
                res = u - v;
                break;

              case "*":
                res = u * v;
                break;

              case "/":
                res = u / v;
                break;

              case "^":
                res = math__namespace.pow(u, v);
                break;

              default:
                alert("unimplemented: SellSymTerm:eval(..): binop: " + op);
            }

            break;

          case "fct1":
            name = element.v[0];
            param = this.eval(var_values, element.v[1]);

            switch (name) {
              case "sin":
                res = math__namespace.sin(param);
                break;

              case "cos":
                res = math__namespace.cos(param);
                break;

              case "exp":
                res = math__namespace.exp(param);
                break;

              case "sqrt":
                res = math__namespace.sqrt(param);
                break;

              default:
                alert("unimplemented: SellSymTerm:eval(..): fct1: " + name);
            }

            break;

          case "fct2":
            name = element.v[0]; //param1 = this.eval(var_values, element.v[1]);
            //param2 = this.eval(var_values, element.v[2]);

            switch (name) {
              case "diff_ode":
              case "diff2_ode":
                var _t = null;
                var _t_id = element.v[1].v.id;
                if (_t_id in var_values) _t = var_values[_t_id];else alert("SellSymTerm:eval(..): unknown term " + _t_id);
                var t_deriv_var_id = element.v[2].v;

                var t_deriv = _t.derivate(t_deriv_var_id);

                if (name === "diff2_ode") t_deriv = t_deriv.derivate(t_deriv_var_id);
                res = t_deriv.eval(var_values); // TODO: (update): should now work: following can be deleted!
                // TODO: THIS CODE MUST BE REWRITTEN, AS IT IS VERY STATIC
                // AND ONLY SUPPORTS  diff(y, x) and diff(diff(y,x), x)!!!!!

                /*let order = 1;
                if(element.v[1].v.type === "function")
                    order = 2;
                t = var_values["y"]; // TODO!!
                let t_deriv_var_id = element.v[2].v;
                let t_deriv = t.derivate(t_deriv_var_id);
                if(order == 2)
                    t_deriv = t_deriv.derivate(t_deriv_var_id);
                res = t_deriv.eval(var_values);
                /*if(element.v[1].v.type === "function") {
                    t = element.v[1].v.value;
                    order = 2;
                } else {
                    let t_id = element.v[1].v.id;
                    if(t_id in var_values)
                        t = var_values[t_id];
                    else
                        alert("SellSymTerm:eval(..): unknown term " + t_id);
                }
                let t_deriv_var_id = element.v[2].v;
                let t_deriv = t.derivate(t_deriv_var_id);
                res = t_deriv.eval(var_values);*/

                break;

              default:
                alert("unimplemented: SellSymTerm:eval(..): fct1: " + name);
            }

            break;

          case "ode_fun":
            var t_id = element.v.id;
            var t = null;
            if (t_id in var_values) t = var_values[t_id];else alert("SellSymTerm:eval(..): unknown term " + t_id);
            res = t.eval(var_values);
            break;

          default:
            alert("unimplemented: SellSymTerm:eval(..): " + element.type);
        }

        return res;
      }
    }, {
      key: "optimize",
      value: function optimize() {
        var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var op, u, v;
        var isRoot = element == null;
        if (isRoot) element = this.stack[0];

        if (element.type === "uniop") {
          op = element.v[0];
          u = this.optimize(element.v[1]);
          element.v[1] = u; // TODO: this was commented out (why??)

          if (op === "-" && u.type == "const" && u.v == 0) {
            element.type = "const";
            element.v = 0;
          }
        } else if (element.type === "fct1") {
          u = this.optimize(element.v[1]);
          element.v[1] = u; // TODO: this was commented out (why??)
        } else if (element.type === "binop") {
          op = element.v[0];
          u = this.optimize(element.v[1]);
          element.v[1] = u; // TODO: this was commented out (why??)

          v = this.optimize(element.v[2]);
          element.v[2] = v; // TODO: this was commented out (why??)
          // calculate constant term

          if (u.type === "const" && v.type === "const") {
            //console.log('***')
            //console.log(u.v)
            //console.log(v.v)
            element.type = "const";

            switch (op) {
              case "+":
                element.v = u.v + v.v;
                break;

              case "-":
                element.v = u.v - v.v;
                break;

              case "*":
                element.v = u.v * v.v;
                break;

              case "/":
                element.v = u.v / v.v;
                break;

              default:
                alert("unimplemented: SellSymTerm:optimize(..): binop: " + op);
            } //console.log(element)

          } // 0, if u or v zero
          else if (op === "*" && (u.type === "const" && u.v == 0 || v.type === "const" && v.v == 0)) {
            element.type = "const";
            element.v = 0;
          } // 1 * v = v
          else if (op === "*" && u.type === "const" && u.v == 1) {
            element.type = v.type;
            element.v = v.v;
          } // (-1) * v = -v
          else if (op === "*" && u.type === "const" && u.v == -1) {
            element = new SellSymTermElement("uniop", ["-", v]);
          } // u * 1 = u
          else if (op === "*" && v.type === "const" && v.v == 1) {
            element.type = u.type;
            element.v = u.v;
          } // u * (-1) = -u
          else if (op === "*" && v.type === "const" && u.v == -1) {
            element = new SellSymTermElement("uniop", ["-", u]);
          } // 0 + v = v
          else if (op === "+" && u.type === "const" && u.v == 0) {
            element.type = v.type;
            element.v = v.v;
          } // u + 0 = u
          else if (op === "+" && v.type === "const" && v.v == 0) {
            element.type = u.type;
            element.v = u.v;
          } // u - 0 = u
          else if (op === "-" && v.type === "const" && v.v == 0) {
            element.type = u.type;
            element.v = u.v;
          } // u^1 = u
          else if (op === "^" && v.type === "const" && v.v == 1) {
            element.type = u.type;
            element.v = u.v;
          } // u - (-v) = u + v
          else if (op === "-" && v.type === "uniop" && v.v[0] === "-") {
            element = new SellSymTermElement("binop", ["+", u, v.v[1]]);
          } // u + (-v) = u - v
          else if (op === "+" && v.type === "uniop" && v.v[0] === "-") {
            element = new SellSymTermElement("binop", ["-", u, v.v[1]]);
          }
        }

        if (isRoot) {
          this.stack[0] = element; //console.log('yyyyy')
          //console.log(this.toString(element))
          //console.log(element.v)
        }

        return element;
      }
    }, {
      key: "integrateNumerically",
      value: function integrateNumerically(varId, a, b) {
        if (b < a) return -this.integrateNumerically(varId, b, a);
        var steps = 1e6; // TODO: configure
        // TODO: must check if all variables are set!! -> error handling!!

        var h = (b - a) / steps;
        var res = 0;

        for (var x = a; x < b; x += h) {
          var f1 = this.eval({
            varId: x
          });
          var f2 = this.eval({
            varId: x + h
          });
          res += (f1 + f2) / 2 * h;
        }

        return res;
      }
    }, {
      key: "compareWithStringTerm",
      value: function compareWithStringTerm(t) {
        var listOfSymbols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        // listOfSymbols is an optional list of symbols that could be present in string input t
        this.state = "";
        if (t.length == 0) t = "0";
        var vars = this.getVariables(); // actually needed variables

        if (listOfSymbols.length > 0) vars = listOfSymbols;
        var n = 50; // TODO: configure number of tests

        var l = -1; // TODO: configure lower bound for EACH variable IN SYNTAX

        var u = 1; // TODO: configure upper bound for EACH variable IN SYNTAX

        var epsilon = 1e-6; // TODO: configure espilon

        for (var i = 0; i < n; i++) {
          var scope = {};

          for (var j = 0; j < vars.length; j++) {
            scope[vars[j]] = math__namespace.random(l, u);
          } //console.log("scope")
          //console.log(scope)
          //console.log("t")
          //console.log(t)


          var res = this.eval(scope);

          if (res > 1000.0) {
            // too large values (e.g. due to exp(x)) are numerically instable: skip them!
            i--; // TODO: can result infinite loops!

            continue;
          }

          var t_res = 0;

          try {
            t_res = math__namespace.evaluate(t, scope);
          } catch (e) {
            this.state = "syntaxerror";
            return false;
          }

          if (typeof t_res !== 'number') {
            this.state = "syntaxerror";
            return false;
          } //console.log(res + " vs " + t_res)
          //console.log("type of res and type of tres: " + typeof(res) + ", " + typeof(t_res) );


          if (math__namespace.abs(res - t_res) >= epsilon) return false;
        }

        return true;
      }
    }]);

    return SellSymTerm;
  }();
  var SellSymTerm_Matrix = /*#__PURE__*/function () {
    function SellSymTerm_Matrix(m, n) {
      var elements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      _classCallCheck(this, SellSymTerm_Matrix);

      this.m = m;
      this.n = n;
      this.elements = elements;
    }

    _createClass(SellSymTerm_Matrix, [{
      key: "toString",
      value: function toString() {
        var s = '[';

        for (var i = 0; i < this.m; i++) {
          if (i > 0) s += ', ';
          s += '[';

          for (var j = 0; j < this.n; j++) {
            if (j > 0) s += ', ';
            s += this.elements[i * this.n + j].toString();
          }

          s += ']';
        }

        s += ']';
        return s;
      }
    }]);

    return SellSymTerm_Matrix;
  }();

  var ParseCode = /*#__PURE__*/function () {
    function ParseCode(parent) {
      _classCallCheck(this, ParseCode);

      this.p = parent;
    }

    _createClass(ParseCode, [{
      key: "getFunctionList",
      value: function getFunctionList() {
        return ['abs', 'binomial', 'integrate', 'conj', 'sqrt', 'xgcd', 'det', 'rank', 'inv', 'eye', 'eigenvalues_sym', 'triu', 'sin', 'cos', 'asin', 'acos', 'tan', 'atan', 'norm2', 'dot', 'cross', 'linsolve', 'is_zero', 'min', 'max'];
      } // code = 
      //   "§CODE_START" { (code_prop | code_hint | assign | prog) "\n" } "§CODE_END";

    }, {
      key: "parseCode",
      value: function parseCode() {
        this.p.terminal('§CODE_START');

        while (!this.p.is('§CODE_END') && !this.p.is('§END')) {
          if (this.p.is("input")) {
            this.parseCodeProp();
            this.p.terminal('§EOL');
          } else if (this.p.is('?')) {
            this.parseCodeHint();
            this.p.terminal('§EOL');
          } else if (this.p.is('JavaBlock') || this.p.is('JavaMethod')) {
            this.p.progParser.parseProg();
          } else {
            this.parseAssign();
            this.p.terminal('§EOL');
          }
        }

        if (!this.p.is("§END")) this.p.terminal('§CODE_END');
      } // code_prop = 
      //   "input" ("rows"|"cols") ":=" ("resizeable"|"static");

    }, {
      key: "parseCodeProp",
      value: function parseCodeProp() {
        if (this.p.is("input")) this.p.next();else this.p.err("expected input");
        var isRows = false;

        if (this.p.is("rows")) {
          this.p.next();
          isRows = true;
        } else if (this.p.is("cols")) {
          this.p.next();
          isRows = false;
        } else this.p.err("expected 'rows' or 'cols'");

        this.p.terminal(":=");
        var isResizable = true;

        if (this.p.is("resizable")) {
          this.p.next();
          isResizable = true;
        } else if (this.p.is("static")) {
          this.p.next();
          isResizable = false;
        } else this.p.err("expected 'resizable' or 'static'");

        if (isRows) this.p.resizableRows = isResizable;else this.p.resizableCols = isResizable;
      } // code_hint = 
      //   "?" text;

    }, {
      key: "parseCodeHint",
      value: function parseCodeHint() {
        if (this.p.is("?")) this.p.next();else this.p.err("expected ?");
        var hintSym = this.p.q.lastParsedInputSymbol;
        if (hintSym == null) this.p.err("Hint/explanation is forbidden, since there is no preceding input field");
        var htmlLen = this.p.q.html.length;
        this.p.textParser.parseText(true
        /*parsingHint=true*/
        );
        hintSym.hint_html = this.p.q.html.substr(htmlLen);
        this.p.q.html = this.p.q.html.substr(0, htmlLen);
      }
    }, {
      key: "chooseFromSet",
      value: function chooseFromSet(set) {
        var v;

        if (set.length == 4 && set[2].type === symtype.T_DOTS) {
          var lowerBound = set[0].value;
          var upperBound = set[3].value;
          var step = parseFloat(set[1].value) - lowerBound;
          v = Math.floor(Math.random() * (upperBound - lowerBound + step) / step) * step + lowerBound;
        } else {
          var idx = Math.floor(Math.random() * set.length);
          v = set[idx].value;
        }

        return v;
      } // assign = 
      //     ID {"," ID} (":="|"=") expr
      //   | ID {"," ID} "in" (matrix_def | set | expr)
      //   | ID "[" expr "," expr "]" (":="|"=") expr
      //   | ID "[" expr "," expr "]" "in" (matrix_def | set | expr)
      //   | ID "(" ID {"," ID} ")" (":="|"=") symbolic_term;

    }, {
      key: "parseAssign",
      value: function parseAssign() {
        this.p.q.stack = []; // set of left-hand side (lhs) variables

        var isFunction = false;
        var lhsIDs = [];
        var lhsSymbolIDs = []; // e.g. for "f(x,y)", we call "x" and "y" symbols

        var lhsMatrixIndexed = false;
        var lhsMatrixRow = 0,
            lhsMatrixCol = 0;
        this.p.ident();
        lhsIDs.push(this.p.id);

        if (this.p.id === 'i' || this.p.id === 'e') {
          // TODO: also test for functions names, ...
          this.p.err("id '" + this.p.id + "' is a reserved symbol");
        }

        if (this.p.is("(")) {
          // function / symbolic term
          isFunction = true;
          this.p.next();
          this.p.ident();
          lhsSymbolIDs.push(this.p.id);

          while (this.p.is(",")) {
            this.p.next();
            this.p.ident();
            lhsSymbolIDs.push(this.p.id);
          }

          this.p.terminal(")");
        } else if (this.p.is("[")) {
          // matrix indexing
          this.p.next();
          lhsMatrixIndexed = true; // row

          this.parseExpr();
          var tos = this.p.q.stack.pop(); // tos := top of stack

          if (tos.type != symtype.T_REAL || !Lexer.isInteger(tos.value)) this.p.err("row index is not an integer value");
          lhsMatrixRow = tos.value; // separator

          this.p.terminal(","); // columns

          this.parseExpr();
          tos = this.p.q.stack.pop(); // tos := top of stack

          if (tos.type != symtype.T_REAL || !Lexer.isInteger(tos.value)) this.p.err("column index is not an integer value");
          lhsMatrixCol = tos.value; // end

          this.p.terminal("]");
        } else {
          // list of lhs-variables only allowed for non-functions
          while (this.p.is(",")) {
            this.p.next();
            this.p.ident();
            lhsIDs.push(this.p.id);
          }
        } // assignment


        if (this.p.is(':=') || this.p.is('=')) {
          this.p.next();
          if (isFunction) this.p.codeSymParser.parseSymbolicTerm(lhsSymbolIDs);else this.parseExpr();
          var rhs = this.p.q.stack.pop();

          if (lhsMatrixIndexed) {
            if (rhs.type != symtype.T_REAL) this.p.err("right-hand side must be of type real");
            if (!(lhsIDs[0] in this.p.q.symbols)) this.p.err("unkown symbol '" + lhsIDs[0] + "'");
            var lhs = this.p.q.symbols[lhsIDs[0]];
            if (lhs.type != symtype.T_MATRIX) this.p.err("symbol '" + lhsIDs[0] + "' is not a matrix");
            lhs.value = SellLinAlg.mat_set_element(lhs.value, lhsMatrixRow - 1, lhsMatrixCol - 1, rhs.value);
            if (lhs.value == null) this.p.err("invalid indices");
          } else {
            for (var i = 0; i < lhsIDs.length; i++) {
              this.p.q.symbols[lhsIDs[i]] = rhs;
            }
          }
        } // choose element of right-hand side (rhs)
        else if (this.p.is('in')) {
          if (isFunction) this.p.err("cannot apply 'in' to a function");
          this.p.next();

          if (this.p.is('MM')) {
            // matrix
            this.parseMatrixDef();

            var _rhs = this.p.q.stack.pop(); // rhs is a matrix definition


            var m = _rhs.value[0];
            var n = _rhs.value[1];
            var set = _rhs.value[2];
            var invertible = _rhs.value[3];
            var symmetric = _rhs.value[4];

            for (var k = 0; k < lhsIDs.length; k++) {
              var value = math__namespace.zeros(m, n);
              var iterations = 0;

              do {
                // run, until all properties are fulfilled
                for (var _i = 0; _i < m; _i++) {
                  for (var j = 0; j < n; j++) {
                    var element = this.chooseFromSet(set.value);
                    value.subset(math__namespace.index(_i, j), element);
                  }
                }

                if (symmetric) {
                  for (var _i2 = 1; _i2 < m; _i2++) {
                    for (var _j = 0; _j < _i2; _j++) {
                      var _element = value.subset(math__namespace.index(_i2, _j));

                      value = value.subset(math__namespace.index(_j, _i2), _element);
                    }
                  }
                }

                if (!invertible) break;
                if (iterations > 256) this.p.err("matrix generation failed: too many iterations");
                iterations++;
              } while (math__namespace.abs(math__namespace.det(value)) < 1e-16); // TODO:epsilon


              this.p.q.symbols[lhsIDs[k]] = new SellSymbol(symtype.T_MATRIX, value);
            }
          } else if (this.p.is('{') || this.p.isIdent()) {
            // set
            if (this.p.is('{')) // TODO: move this to parseUnary!
              this.parseSet();else this.parseExpr();

            var _rhs2 = this.p.q.stack.pop();

            if (_rhs2.type != symtype.T_SET) this.p.err("expected a set"); // run until (optional) constrains are met

            var lex_backup = this.p.backupLexer();
            var ctr = 0;

            while (true) {
              if (ctr > 1000) this.p.err("constraints for random variables cannot be fulfilled");
              ctr++;

              for (var _i3 = 0; _i3 < lhsIDs.length; _i3++) {
                var _value = this.chooseFromSet(_rhs2.value);

                this.p.q.symbols[lhsIDs[_i3]] = new SellSymbol(symtype.T_REAL, _value);
              } // optional constraint(s)


              this.p.replayLexer(lex_backup);

              if (this.p.is('with')) {
                this.p.next();
                this.parseExpr();

                var _tos = this.p.q.stack.pop(); // tos := top of stack


                if (_tos.type != symtype.T_BOOL) this.p.err("constraint must be boolean");
                if (_tos.value) break;
              } else break; // if no constraints are set: stop

            }
          } else this.p.err("unexpected '" + this.p.tk + "'");
        } else this.p.err("expected ':=' or '=' or 'in'");
      } // expr =
      //   or;

    }, {
      key: "parseExpr",
      value: function parseExpr() {
        this.parseOr();
      } // or =
      //   and [ "or" and ];

    }, {
      key: "parseOr",
      value: function parseOr() {
        this.parseAnd();

        if (this.p.is('or')) {
          var op = this.p.tk;
          this.p.next();
          this.parseAnd();
          var o2 = this.p.q.stack.pop();
          var o1 = this.p.q.stack.pop();

          if (o1.type == symtype.T_BOOL && o2.type == symtype.T_BOOL) {
            this.p.pushSym(symtype.T_BOOL, o1.value || o2.value);
          } else this.p.err("types not compatible for '" + op + "' (must be boolean)");
        }
      } // and =
      //   equal [ "and" equal ];

    }, {
      key: "parseAnd",
      value: function parseAnd() {
        this.parseEqual();

        if (this.p.is('and')) {
          var op = this.p.tk;
          this.p.next();
          this.parseEqual();
          var o2 = this.p.q.stack.pop();
          var o1 = this.p.q.stack.pop();

          if (o1.type == symtype.T_BOOL && o2.type == symtype.T_BOOL) {
            this.p.pushSym(symtype.T_BOOL, o1.value && o2.value);
          } else this.p.err("types not compatible for '" + op + "' (must be boolean)");
        }
      } // equal =
      //   compare [ ("=="|"!=") compare ];

    }, {
      key: "parseEqual",
      value: function parseEqual() {
        this.parseCompare();

        if (this.p.is('==') || this.p.is('!=')) {
          var op = this.p.tk;
          this.p.next();
          this.parseCompare();
          var o2 = this.p.q.stack.pop();
          var o1 = this.p.q.stack.pop();

          if (o1.type == symtype.T_REAL && o2.type == symtype.T_REAL) {
            var isEqual = math__namespace.abs(o1.value - o2.value) < 1e-14;

            switch (op) {
              case '==':
                this.p.pushSym(symtype.T_BOOL, isEqual);
                break;

              case '!=':
                this.p.pushSym(symtype.T_BOOL, !isEqual);
                break;
            }
          } else if (o1.type == symtype.T_MATRIX && o2.type == symtype.T_MATRIX) {
            var _isEqual = SellLinAlg.mat_compare_numerically(o1.value, o2.value);

            switch (op) {
              case '==':
                this.p.pushSym(symtype.T_BOOL, _isEqual);
                break;

              case '!=':
                this.p.pushSym(symtype.T_BOOL, !_isEqual);
                break;
            }
          } else this.p.err("types not compatible for '" + op + "'");
        }
      } // compare =
      //   add [ ("<="|"<"|">="|">") add ];

    }, {
      key: "parseCompare",
      value: function parseCompare() {
        this.parseAdd();

        if (this.p.is('<=') || this.p.is('<') || this.p.is('>=') || this.p.is('>')) {
          var op = this.p.tk;
          this.p.next();
          this.parseAdd();
          var o2 = this.p.q.stack.pop();
          var o1 = this.p.q.stack.pop();

          if (o1.type == symtype.T_REAL && o2.type == symtype.T_REAL) {
            switch (op) {
              case '<=':
                this.p.pushSym(symtype.T_BOOL, o1.value <= o2.value);
                break;

              case '<':
                this.p.pushSym(symtype.T_BOOL, o1.value < o2.value);
                break;

              case '>=':
                this.p.pushSym(symtype.T_BOOL, o1.value >= o2.value);
                break;

              case '>':
                this.p.pushSym(symtype.T_BOOL, o1.value > o2.value);
                break;
            }
          } else this.p.err("types not compatible for '" + op + "'");
        }
      } // add =
      //   mul { ("+"|"-") mul };

    }, {
      key: "parseAdd",
      value: function parseAdd() {
        this.parseMul();

        while (this.p.is('+') || this.p.is('-')) {
          var op = this.p.tk;
          this.p.next();
          this.parseMul();
          var o2 = this.p.q.stack.pop();
          var o1 = this.p.q.stack.pop();

          if (o1.type == symtype.T_REAL && o2.type == symtype.T_REAL) {
            switch (op) {
              case '+':
                this.p.pushSym(symtype.T_REAL, o1.value + o2.value);
                break;

              case '-':
                this.p.pushSym(symtype.T_REAL, o1.value - o2.value);
                break;
            }
          } else if ((o1.type == symtype.T_REAL || o1.type == symtype.T_COMPLEX) && (o2.type == symtype.T_REAL || o2.type == symtype.T_COMPLEX)) {
            switch (op) {
              case '+':
                this.p.pushSym(symtype.T_COMPLEX, math__namespace.add(o1.value, o2.value));
                break;

              case '-':
                this.p.pushSym(symtype.T_COMPLEX, math__namespace.subtract(o1.value, o2.value));
                break;
            }
          } else if (o1.type == symtype.T_MATRIX && o2.type == symtype.T_MATRIX) {
            var o1_m = o1.value.size()[0];
            var o1_n = o1.value.size()[1];
            var o2_m = o2.value.size()[0];
            var o2_n = o2.value.size()[1];
            if (o1_m != o2_m || o1_n != o2_n) this.p.err("cannot apply '" + op + "' on (" + o1_m + "x" + o1_n + ") and (" + o2_m + "x" + o2_n + ") matrices");
            this.p.pushSym(symtype.T_MATRIX, op == "+" ? math__namespace.add(o1.value, o2.value) : math__namespace.subtract(o1.value, o2.value));
          } else this.p.err("types not compatible for '" + op + "'");
        }
      } // mul =
      //   pow { ("*"|"/"|"mod") pow };

    }, {
      key: "parseMul",
      value: function parseMul() {
        this.parsePow();

        while (this.p.is('*') || this.p.is('/') || this.p.is('mod')) {
          var op = this.p.tk;
          this.p.next();
          this.parsePow();
          var o2 = this.p.q.stack.pop();
          var o1 = this.p.q.stack.pop();

          if (o1.type == symtype.T_REAL && o2.type == symtype.T_REAL) {
            switch (op) {
              case '*':
                this.p.pushSym(symtype.T_REAL, o1.value * o2.value);
                break;

              case '/':
                this.p.pushSym(symtype.T_REAL, o1.value / o2.value);
                break;

              case 'mod':
                if (!this.p.isNumberInt(o1.value) || !this.p.isNumberInt(o2.value)) this.p.err("operator 'mod' expectes integral operands");
                this.p.pushSym(symtype.T_REAL, math__namespace.mod(math__namespace.round(o1.value), math__namespace.round(o2.value)));
                break;
            }
          } else if ((o1.type == symtype.T_REAL || o1.type == symtype.T_COMPLEX) && (o2.type == symtype.T_REAL || o2.type == symtype.T_COMPLEX)) {
            switch (op) {
              case '*':
                this.p.pushSym(symtype.T_COMPLEX, math__namespace.multiply(o1.value, o2.value));
                break;

              case '/':
                this.p.pushSym(symtype.T_COMPLEX, math__namespace.divide(o1.value, o2.value));
                break;

              case 'mod':
                this.p.err("types not compatible for '" + op + "'");
                break;
            }
          } else if (o1.type == symtype.T_MATRIX && o2.type == symtype.T_MATRIX) {
            switch (op) {
              case '*':
                var o1_m = o1.value.size()[0];
                var o1_n = o1.value.size()[1];
                var o2_m = o2.value.size()[0];
                var o2_n = o2.value.size()[1];
                if (o1_n != o2_m) this.p.err("cannot multiply (" + o1_m + "x" + o1_n + ") and (" + o2_m + "x" + o2_n + ") matrices");
                this.p.pushSym(symtype.T_MATRIX, math__namespace.multiply(o1.value, o2.value));
                break;

              case '/':
              case 'mod':
                this.p.err("types not compatible for '" + op + "'");
                break;
            }
          } else if (o1.type == symtype.T_MATRIX && o2.type == symtype.T_REAL) {
            switch (op) {
              case '*':
                this.p.pushSym(symtype.T_MATRIX, math__namespace.multiply(o1.value, o2.value));
                break;

              case 'mod':
                // TODO: must test, if all elements of matrix are integral!
                if (!this.p.isNumberInt(o2.value)) this.p.err("operator 'mod' expectes integral operands");
                this.p.pushSym(symtype.T_MATRIX, SellLinAlg.mat_mod(o1.value, o2.value));
                break;

              default:
                console.log(o1.value.toString());
                this.p.err("types not compatible for '" + op + "'");
                break;
            }
          } else if (o1.type == symtype.T_REAL && o2.type == symtype.T_MATRIX) {
            switch (op) {
              case '*':
                this.p.pushSym(symtype.T_MATRIX, math__namespace.multiply(o1.value, o2.value));
                break;

              default:
                this.p.err("types not compatible for '" + op + "'");
                break;
            }
          } else this.p.err("types not compatible for '" + op + "'");
        }
      } // pow =
      //   unary { ("^") unary };

    }, {
      key: "parsePow",
      value: function parsePow() {
        this.parseUnary();

        while (this.p.is('^')) {
          var op = this.p.tk;
          this.p.next();
          this.parseUnary();
          var o2 = this.p.q.stack.pop();
          var o1 = this.p.q.stack.pop();

          if (o1.type == symtype.T_REAL && o2.type == symtype.T_REAL) {
            switch (op) {
              case '^':
                this.p.pushSym(symtype.T_REAL, math__namespace.pow(o1.value, o2.value));
                break;
            }
          } else if ((o1.type == symtype.T_REAL || o1.type == symtype.T_COMPLEX) && (o2.type == symtype.T_REAL || o2.type == symtype.T_COMPLEX)) {
            switch (op) {
              case '^':
                this.p.pushSym(symtype.T_COMPLEX, math__namespace.pow(o1.value, o2.value));
                break;
            }
          } else if (o1.type == symtype.T_MATRIX && o2.type == symtype.T_MATRIX_TRANSPOSE) {
            switch (op) {
              case '^':
                this.p.pushSym(symtype.T_MATRIX, math__namespace.transpose(o1.value));
                break;
            }
          } else this.p.err("types not compatible for '" + op + "'");
        }
      } // unary = (
      //   | "-" unary;
      //   | INT [ "." INT ]
      //   | "true" | "false"
      //   | "not" unary
      //   | "i" | "j" | "T"
      //   | function_call
      //   | ID [ "(" add { "," add } ")" ]
      //   | "..."
      //   | matrix
      //   | "(" expr ")"
      // ) [ factorial ];

    }, {
      key: "parseUnary",
      value: function parseUnary() {
        if (this.p.is('-')) {
          this.p.next();
          this.parseUnary();
          var o = this.p.q.stack.pop();
          if (o.type == symtype.T_REAL) this.p.pushSym(symtype.T_REAL, -o.value);else this.p.err("unary '-' must be followed by type real");
        } else if (this.p.isInt()) {
          var value = parseInt(this.p.tk);
          this.p.next();

          if (this.p.is('.')) {
            this.p.next();
            if (!Lexer.isInteger(this.p.tk)) this.p.err("expected decimal places after '.'");
            value = parseFloat("" + value + "." + this.p.tk);
            this.p.next();
          }

          this.p.q.stack.push(new SellSymbol(symtype.T_REAL, value));
        } else if (this.p.is("true")) {
          this.p.next();
          this.p.q.stack.push(new SellSymbol(symtype.T_BOOL, true));
        } else if (this.p.is("false")) {
          this.p.next();
          this.p.q.stack.push(new SellSymbol(symtype.T_BOOL, false));
        } else if (this.p.is("not")) {
          this.p.next();
          this.parseUnary();
          var u = this.p.q.stack.pop();
          if (u.type != symtype.T_BOOL) this.p.err("expected boolean datatype as argument for 'not'");
          this.p.q.stack.push(new SellSymbol(symtype.T_BOOL, !u.value));
        } else if (this.p.is("i") || this.p.is("j")) {
          this.p.q.stack.push(new SellSymbol(symtype.T_COMPLEX, math__namespace.complex(0, 1)));
          this.p.next();
        } else if (this.p.is("T")) {
          this.p.q.stack.push(new SellSymbol(symtype.T_MATRIX_TRANSPOSE, "T"));
          this.p.next();
        } else if (this.getFunctionList().includes(this.p.tk)) {
          this.parseFunctionCall();
        } else if (this.p.isIdent()) {
          var id = this.p.tk;
          this.p.next();
          if (id in this.p.q.symbols == false) this.p.err("unknown identifier '" + id + "'");
          var sym = this.p.q.symbols[id];

          if (sym.type == symtype.T_FUNCTION && this.p.is("(")) {
            this.p.next();
            this.parseAdd();
            var args = [this.p.q.stack.pop()];

            while (this.p.is(",")) {
              this.p.next();
              this.parseAdd();
              args.push(this.p.q.stack.pop());
            }

            var term = sym.value;
            var termSymIDs = term.symbolIDs;
            if (termSymIDs.length != args.length) this.p.err("number of arguments does not correspond to function definition");
            var args_dict = {};

            for (var i = 0; i < termSymIDs.length; i++) {
              if (args[i].type != symtype.T_REAL) this.p.err("all arguements must be scalar and real valued");
              args_dict[termSymIDs[i]] = args[i].value;
            }

            var v = term.eval(args_dict);
            var v_sym = new SellSymbol(symtype.T_REAL, v);
            this.p.q.stack.push(v_sym);
            this.p.terminal(')');
          } else this.p.q.stack.push(sym);
        } else if (this.p.is("...")) {
          this.p.next();
          this.p.q.stack.push(new SellSymbol(symtype.T_DOTS));
        } else if (this.p.is("{")) {
          this.parseSet();
        } else if (this.p.is("[")) {
          this.parseMatrix();
        } else if (this.p.is("(")) {
          this.p.next();
          this.parseExpr();
          this.p.terminal(")");
        } else this.p.err("expected unary, got '" + this.p.tk + "'"); // postfix


        if (this.p.is('!')) this.parseFactorial();
      } // matrix =
      //   "[" "[" expr {"," expr} "]" { "," "[" expr {"," expr} "]" } "]";

    }, {
      key: "parseMatrix",
      value: function parseMatrix() {
        this.p.terminal('[');
        var cols = -1;
        var rows = 0;
        var elements = [];
        var elementsType = null;

        while (this.p.is('[') || this.p.is(',')) {
          if (rows > 0) this.p.terminal(',');
          this.p.terminal('[');
          var col = 0;

          while (!this.p.is(']') && !this.p.is('§EOF')) {
            if (col > 0) this.p.terminal(',');
            this.parseExpr();
            var element = this.p.q.stack.pop();
            if (element.type != symtype.T_REAL && element.type != symtype.T_FUNCTION) this.p.err("matrix element must be of type real or function");
            if (elementsType == null) elementsType = element.type;else if (element.type != elementsType) this.p.err("all matrix elements must have same type");
            elements.push(element.value);
            col++;
          }

          if (cols == -1) cols = col;else if (col != cols) this.p.err('matrix has different number of cols per row');
          this.p.terminal(']');
          rows++;
        }

        if (rows < 1 || cols < 1) this.p.err('matrix must have at least one row and one column');
        this.p.terminal(']'); // create matrix:

        var matrix = null;
        var matrixType = elementsType == symtype.T_REAL ? symtype.T_MATRIX : symtype.T_MATRIX_OF_FUNCTIONS;

        if (matrixType == symtype.T_MATRIX) {
          matrix = math__namespace.zeros(rows, cols);
          sellassert(elements.length == rows * cols);

          for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
              matrix = SellLinAlg.mat_set_element(matrix, i, j, elements[i * cols + j]);
            }
          }
        } else {
          // matrixType == symtype.T_MATRIX_OF_FUNCTIONS
          matrix = new SellSymTerm_Matrix(rows, cols, elements);
        }

        this.p.q.stack.push(new SellSymbol(matrixType, matrix));
      } // function_call = 
      //   ("abs"|"binomial"|"integrate"|"conj"|"sqrt"|"xgcd"|"det"|"rank"|"inv"
      //      |"eye"|"eigenvalues_sym"|"triu"|"sin"|"cos"|"asin"|"acos"|"tan"
      //      |"atan"|"norm2"|"dot"|"cross"|"linsolve"| "is_zero")
      //   ID "(" [ expr {"," expr} ] ")";

    }, {
      key: "parseFunctionCall",
      value: function parseFunctionCall() {
        this.p.ident();
        var functionName = this.p.id;
        this.p.terminal('('); // get parameters =: p

        var p = [];

        while (!this.p.is(')') && !this.p.is('§EOL') && !this.p.is('§EOF')) {
          if (p.length > 0) this.p.terminal(',');

          if (functionName == "integrate" && p.length == 1) {
            // second parametr of "integrate" must be a string
            this.p.ident();
            p.push(this.p.id);
          } else {
            this.parseExpr();
            p.push(this.p.q.stack.pop());
          }
        }

        this.p.terminal(')'); // calculate

        if (functionName === 'abs') {
          if (p.length != 1 || p[0].type != symtype.T_REAL && p[0].type != symtype.T_COMPLEX) this.p.err("signature must be 'abs(real|complex)'");
          this.p.pushSym(symtype.T_REAL, math__namespace.abs(p[0].value));
        } else if (functionName === 'sqrt') {
          if (p.length != 1 || p[0].type != symtype.T_REAL && p[0].type != symtype.T_COMPLEX) this.p.err("signature must be 'sqrt(real|complex)'");
          var v = math__namespace.sqrt(p[0].value);
          var isComplex = math__namespace.typeOf(v) == 'Complex';
          this.p.pushSym(isComplex ? symtype.T_COMPLEX : symtype.T_REAL, v);
        } else if (['sin', 'asin', 'cos', 'acos', 'tan', 'atan'].includes(functionName)) {
          if (p.length != 1 || p[0].type != symtype.T_REAL) this.p.err("signature must be '" + functionName + "(real)'");
          var _v = 0.0;

          switch (functionName) {
            case 'sin':
              _v = math__namespace.sin(p[0].value);
              break;

            case 'asin':
              _v = math__namespace.asin(p[0].value);
              break;

            case 'cos':
              _v = math__namespace.cos(p[0].value);
              break;

            case 'acos':
              _v = math__namespace.acos(p[0].value);
              break;

            case 'tan':
              _v = math__namespace.tan(p[0].value);
              break;

            case 'atan':
              _v = math__namespace.atan(p[0].value);
              break;

            default:
              this.p.err("UNIMPLEMENTED: " + functionName);
          }

          this.p.pushSym(symtype.T_REAL, _v);
        } else if (functionName === 'conj') {
          if (p.length != 1 || p[0].type != symtype.T_COMPLEX) this.p.err("signature must be 'conj(complex)'");
          this.p.pushSym(symtype.T_COMPLEX, math__namespace.conj(p[0].value));
        } else if (functionName === 'binomial') {
          if (p.length != 2 || p[0].type != symtype.T_REAL || p[1].type != symtype.T_REAL || !this.p.isNumberInt(p[0].value) || !this.p.isNumberInt(p[1].value)) this.p.err("signature must be 'binomial(int,int)'");
          this.p.pushSym(symtype.T_REAL, math__namespace.combinations(math__namespace.round(p[0].value), math__namespace.round(p[1].value)));
        } else if (functionName === 'xgcd') {
          if (p.length != 3 || p[0].type != symtype.T_REAL || p[1].type != symtype.T_REAL || p[2].type != symtype.T_REAL || !this.p.isNumberInt(p[0].value) || !this.p.isNumberInt(p[1].value) || !this.p.isNumberInt(p[2].value)) this.p.err("signature must be 'xgcd(int,int,int)'");
          this.p.pushSym(symtype.T_REAL, math__namespace.subset(math__namespace.xgcd(p[0].value, p[1].value), math__namespace.index(p[2].value - 1)));
        } else if (functionName === 'integrate') {
          if (p.length != 4 || p[0].type != symtype.T_FUNCTION || typeof p[1] !== 'string' || p[2].type != symtype.T_REAL || p[3].type != symtype.T_REAL) this.p.err("signature must be 'integrate(function, string, real, real)'");

          var _v2 = p[0].value.integrateNumerically(p[1], p[2].value, p[3].value);

          var precision = 0.001;
          this.p.pushSym(symtype.T_REAL, _v2, precision);
        } else if (['det', 'rank', 'inv', 'eigenvalues_sym', 'triu', 'norm2'].includes(functionName)) {
          if (p.length != 1 || p[0].type != symtype.T_MATRIX) this.p.err("signature must be '" + functionName + "(matrix)'");
          if (functionName === 'det') this.p.pushSym(symtype.T_REAL, math__namespace.det(p[0].value));else if (functionName === 'rank') this.p.pushSym(symtype.T_REAL, SellLinAlg.mat_rank(p[0].value));else if (functionName === 'inv') this.p.pushSym(symtype.T_MATRIX, math__namespace.inv(p[0].value));else if (functionName === 'eigenvalues_sym') {
            if (!SellLinAlg.mat_is_symmetric(p[0].value)) this.p.err("matrix is not symmetric");

            var eigs = math__namespace.eigs(p[0].value).values._data;

            var set = [];

            for (var i = 0; i < eigs.length; i++) {
              set.push(new SellSymbol(symtype.T_REAL, eigs[i]));
            }

            this.p.pushSym(symtype.T_SET, set);
          } else if (functionName === 'triu') {
            this.p.pushSym(symtype.T_MATRIX, SellLinAlg.mat_triu(p[0].value));
          } else if (functionName === 'norm2') {
            this.p.pushSym(symtype.T_REAL, SellLinAlg.mat_norm2(p[0].value));
          } else sellassert(false);
        } else if (functionName === 'eye') {
          if (p.length != 1 || p[0].type != symtype.T_REAL || !this.p.isNumberInt(p[0].value)) this.p.err("signature must be 'eye(integer)'");
          this.p.pushSym(symtype.T_MATRIX, math__namespace.identity(math__namespace.round(p[0].value)));
        } else if (functionName === 'dot') {
          if (p.length != 2 || p[0].type != symtype.T_MATRIX || p[1].type != symtype.T_MATRIX) this.p.err("signature must be 'dot(columnVector,columnVector)'");
          if (SellLinAlg.mat_get_col_count(p[0].value) != 1) this.p.err("signature must be 'dot(columnVector,columnVector)'");
          if (SellLinAlg.mat_get_col_count(p[1].value) != 1) this.p.err("signature must be 'dot(columnVector,columnVector)'");
          if (SellLinAlg.mat_get_row_count(p[0].value) != SellLinAlg.mat_get_row_count(p[1].value)) this.p.err("vectors in 'dot(..)' must have equal length");
          this.p.pushSym(symtype.T_REAL, SellLinAlg.mat_vecdot(p[0].value, p[1].value));
        } else if (functionName === 'cross') {
          if (p.length != 2 || p[0].type != symtype.T_MATRIX || p[1].type != symtype.T_MATRIX) this.p.err("signature must be 'cross(columnVector,columnVector)'");
          if (SellLinAlg.mat_get_col_count(p[0].value) != 1) this.p.err("signature must be 'cross(columnVector,columnVector)'");
          if (SellLinAlg.mat_get_col_count(p[1].value) != 1) this.p.err("signature must be 'cross(columnVector,columnVector)'");
          if (SellLinAlg.mat_get_row_count(p[0].value) != 3) this.p.err("vectors in 'cross(..)' must have length 3");
          if (SellLinAlg.mat_get_row_count(p[1].value) != 3) this.p.err("vectors in 'cross(..)' must have length 3");
          this.p.pushSym(symtype.T_MATRIX, SellLinAlg.mat_veccross(p[0].value, p[1].value));
        } else if (functionName === 'linsolve') {
          if (p.length != 2 || p[0].type != symtype.T_MATRIX || p[1].type != symtype.T_MATRIX) this.p.err("signature must be 'linsolve(matrix,columnVector)'");
          if (SellLinAlg.mat_get_col_count(p[0].value) != SellLinAlg.mat_get_row_count(p[0].value)) this.p.err("matrix must be square, i.e. m=n");
          if (SellLinAlg.mat_get_col_count(p[1].value) != 1) this.p.err("second parameter must be a colum vector");
          if (SellLinAlg.mat_get_row_count(p[0].value) != SellLinAlg.mat_get_row_count(p[1].value)) this.p.err("number of rows of matrix and does not match vector");
          this.p.pushSym(symtype.T_MATRIX, SellLinAlg.linsolve(p[0].value, p[1].value));
        } else if (functionName === 'is_zero') {
          if (p.length != 1 || p[0].type != symtype.T_MATRIX) this.p.err("signature must be 'is_zero(matrix)'");
          this.p.pushSym(symtype.T_BOOL, SellLinAlg.mat_is_zero(p[0].value));
        } else if (functionName === 'min') {
          if (p.length != 1 || p[0].type != symtype.T_SET) this.p.err("signature must be 'min(set)'");
          var _v3 = 1e13;

          for (var _i4 = 0; _i4 < p[0].value.length; _i4++) {
            if (p[0].value[_i4].value < _v3) _v3 = p[0].value[_i4].value;
          }

          this.p.pushSym(symtype.T_REAL, _v3);
        } else if (functionName === 'max') {
          if (p.length != 1 || p[0].type != symtype.T_SET) this.p.err("signature must be 'max(set)'");

          var _v4 = -1e13;

          for (var _i5 = 0; _i5 < p[0].value.length; _i5++) {
            if (p[0].value[_i5].value > _v4) _v4 = p[0].value[_i5].value;
          }

          this.p.pushSym(symtype.T_REAL, _v4);
        } else this.p.err("unimplemented function call '" + functionName + "'");
      } // factorial =
      //   "!";

    }, {
      key: "parseFactorial",
      value: function parseFactorial() {
        this.p.terminal('!');
        var op = '!';
        var o = this.p.q.stack.pop();
        if (o.type == symtype.T_REAL) this.p.pushSym(symtype.T_REAL, math__namespace.factorial(o.value));else this.p.err("types not compatible for '" + op + "'");
      } // matrix_def = 
      //   "MM" "(" expr "x" expr "|" expr [ {"," ("invertible"|"symmetric")} ] ")";

    }, {
      key: "parseMatrixDef",
      value: function parseMatrixDef() {
        this.p.terminal("MM");
        this.p.terminal("("); // number of rows

        this.parseExpr();
        var m = this.p.q.stack.pop();
        if (m.type !== symtype.T_REAL || !this.p.isNumberInt(m.value)) this.p.err("expected integer for the number of rows");
        var rows = math__namespace.round(m.value);
        if (rows <= 0) this.p.err("number of matrix cols must be > 0 (actually is '" + rows + "')"); // times

        this.p.terminal("x"); // number of columns

        this.parseExpr();
        var n = this.p.q.stack.pop();
        if (n.type !== symtype.T_REAL || !this.p.isNumberInt(n.value)) this.p.err("expected integer for the number of columns");
        var cols = math__namespace.round(n.value);
        if (cols <= 0) this.p.err("number of matrix rows must be > 0 (actually is '" + cols + "')"); // set

        this.p.terminal("|");
        this.parseExpr();
        var set = this.p.q.stack.pop();
        if (set.type !== symtype.T_SET) this.p.err("expected set from which matrix elements are drawn"); // properties

        var invertible = false;
        var symmetric = false;

        while (this.p.is(",")) {
          this.p.next();
          var prop = this.p.tk;

          switch (prop) {
            case 'invertible':
              invertible = true;
              break;

            case 'symmetric':
              symmetric = true;
              break;

            default:
              this.p.err("unknown property '" + prop + "'");
          }

          this.p.next();
        } // end


        this.p.terminal(")"); // create symbol

        this.p.pushSym(symtype.T_MATRIX_DEF, [rows, cols, set, invertible, symmetric]);
      } // set = 
      //   "{" [ expr { "," expr } ] "}";

    }, {
      key: "parseSet",
      value: function parseSet() {
        this.p.terminal("{");
        var idx = 0;
        var sym = new SellSymbol(symtype.T_SET);
        sym.value = [];
        var hasDot = false;

        while (!this.p.is('}') && !this.p.is('§EOF')) {
          if (idx > 0) this.p.terminal(",");
          this.parseExpr();
          var symi = this.p.q.stack.pop();
          sym.value.push(symi);

          if (symi.type !== symtype.T_REAL) {
            if (idx == 2 && symi.type === symtype.T_DOTS) hasDot = true;else if (symi.type === symtype.T_COMPLEX) sym.type = symtype.T_COMPLEX_SET;else this.p.err("set must consist of real values only");
          }

          idx++;
        }

        if (hasDot && idx != 4 || hasDot && sym.type == symtype.T_COMPLEX_SET) this.p.err("if set contains '...', then it must have 4 real-valued elements");

        if (sym.type == symtype.T_COMPLEX_SET) {
          for (var i = 0; i < sym.value.length; i++) {
            if (sym.value[i].type == symtype.T_REAL) sym.value[i].value = math__namespace.complex(sym.value[i].value, 0);
          }
        }

        this.p.q.stack.push(sym);
        this.p.terminal("}");
      }
    }]);

    return ParseCode;
  }();

  var ParseCodeSym = /*#__PURE__*/function () {
    function ParseCodeSym(parent) {
      _classCallCheck(this, ParseCodeSym);

      this.p = parent;
    } // symbolic_term = 
    //   symbolic_term_add;


    _createClass(ParseCodeSym, [{
      key: "parseSymbolicTerm",
      value: function parseSymbolicTerm(lhsSymbolIDs) {
        var symterm = new SellSymTerm(lhsSymbolIDs);
        this.parseSymbolicTerm_Add(symterm);
        symterm.optimize();
        this.p.q.stack.push(new SellSymbol(symtype.T_FUNCTION, symterm));
      } // symbolic_term_expr = 
      //   symbolic_term_add;

    }, {
      key: "parseSymbolicTerm_Expr",
      value: function parseSymbolicTerm_Expr(symterm) {
        this.parseSymbolicTerm_Add(symterm);
      } // symbolic_term_add = 
      //   symbolic_term_mul { ("+"|"-") symbolic_term_mul };

    }, {
      key: "parseSymbolicTerm_Add",
      value: function parseSymbolicTerm_Add(symterm) {
        this.parseSymbolicTerm_Mul(symterm);

        while (this.p.is("+") || this.p.is("-")) {
          var op = this.p.tk;
          this.p.next();
          this.parseSymbolicTerm_Mul(symterm);
          symterm.pushBinaryOperation(op);
        }
      } // symbolic_term_mul = 
      //   symbolic_term_pow { ("*"|"/") symbolic_term_pow };

    }, {
      key: "parseSymbolicTerm_Mul",
      value: function parseSymbolicTerm_Mul(symterm) {
        this.parseSymbolicTerm_Pow(symterm);

        while (this.p.is("*") || this.p.is("/")) {
          var op = this.p.tk;
          this.p.next();
          this.parseSymbolicTerm_Pow(symterm);
          symterm.pushBinaryOperation(op);
        }
      } // symbolic_term_pow = 
      //   symbolic_term_unary { "^" symbolic_term_unary };

    }, {
      key: "parseSymbolicTerm_Pow",
      value: function parseSymbolicTerm_Pow(symterm) {
        this.parseSymbolicTerm_Unary(symterm);

        while (this.p.is("^")) {
          var op = this.p.tk;
          this.p.next();
          this.parseSymbolicTerm_Unary(symterm);
          symterm.pushBinaryOperation(op);
        }
      } // symbolic_term_unary = 
      //     "(" symbolic_term_expr ")" 
      //   | INT ["!"] 
      //   | FLOAT
      //   | ("exp"|"sin"|"cos"|"sqrt") "(" symbolic_term_expr ")"
      //   | "diff" "(" symbolic_term_expr "," ID  ")"
      //   | ID 
      //   | ID "(" [ expr { "," epxr } ] ")"
      //   | "-" symbolic_term_pow;

    }, {
      key: "parseSymbolicTerm_Unary",
      value: function parseSymbolicTerm_Unary(symterm) {
        if (this.p.is("(")) {
          this.p.terminal("(");
          this.parseSymbolicTerm_Expr(symterm);
          this.p.terminal(")");
        } else if (this.p.isNumber()) {
          var value = parseFloat(this.p.tk);
          this.p.next();

          if (this.p.is("!")) {
            if (!this.p.isNumberInt(value)) this.p.err("expected integer for '!'");
            this.p.next();
            value = math__namespace.factorial(value);
          }

          symterm.pushConstant(value);
        } else if (["exp", "sin", "cos", "sqrt"].includes(this.p.tk)) {
          // functions with 1 parameter
          var fctId = this.p.tk;
          this.p.next();
          this.p.terminal("(");
          this.parseSymbolicTerm_Expr(symterm);
          this.p.terminal(")");
          symterm.pushUnaryFunction(fctId);
        } else if (this.p.is("diff")) {
          this.p.next();
          this.p.terminal("(");
          this.parseSymbolicTerm_Expr(symterm); //let diff_fct = symterm.stack[symterm.stack.length - 1];

          /*this.p.ident();
          let diff_fctId = this.p.id;
          if((diff_fctId in this.p.q.symbols) == false)
              this.p.err("unknown function '" + diff_fctId + "'");
          let diff_fct = this.p.q.symbols[diff_fctId];
          if(symterm.symbolIDs.length != diff_fct.value.symbolIDs.length)
              this.p.err("cannot apply diff(): set of variables does not correspond to left-hand side");
          for(let i=0; i<symterm.symbolIDs.length; i++) {
              if(symterm.symbolIDs[i] !== diff_fct.value.symbolIDs[i])
                  this.p.err("cannot apply diff(): set of variables does not correspond to left-hand side");
          }*/

          /*TODO: if(diff_fct.type !== symtype.T_FUNCTION)
              this.p.err("first parameter of 'diff' must be a function");*/

          this.p.terminal(",");
          this.p.ident();
          var diff_symId = this.p.id;
          this.p.terminal(")");
          symterm.pushVariable(diff_symId);
          /*TODO: if(!diff_fct.value.symbolIDs.includes(diff_symId))
              this.p.err("cannot apply diff(): '" + diff_symId + "' is not a variable of function '" + diff_fctId + "'");*/
          //let diff = diff_fct.value.derivate(diff_symId);
          //symterm.pushSymbolicTerm(diff);

          symterm.pushDiff();
        } else if (this.p.isIdent()) {
          var id = this.p.tk;
          this.p.next();

          if (id in this.p.q.symbols) {
            var symbol = this.p.q.symbols[id];
            if (symbol.type === symtype.T_REAL) symterm.pushConstant(symbol.value);else if (symbol.type == symtype.T_FUNCTION) {
              if (this.p.is("(")) {
                var evalParameters = [];
                this.p.terminal("(");

                while (!this.p.is(")") && !this.p.is("§EOF")) {
                  if (evalParameters.length > 0) this.p.terminal(",");
                  this.p.codeParser.parseExpr(); // must be an evaluted term, not a symbolic term!

                  var evalParameter = this.p.q.stack.pop();
                  if (evalParameter.type !== symtype.T_REAL) this.p.err("paremeter must be of type 'real'");
                  evalParameters.push(evalParameter.value);
                }

                this.p.terminal(")");
                if (symbol.value.symbolIDs.length != evalParameters.length) this.p.err("number of parameters does not match definition of function '" + id + "'");
                var varValues = {};

                for (var i = 0; i < symbol.value.symbolIDs.length; i++) {
                  varValues[symbol.value.symbolIDs[i]] = evalParameters[i];
                }

                symterm.pushConstant(symbol.value.eval(varValues));
              } else {
                symterm.pushSymbolicTerm(symbol.value);
              }
            } else this.p.err("identifer '" + id + "' must be of type 'real'");
          } else symterm.pushVariable(id); // TODO: check, if it is in symbolIDs (member of SellSymbolicTerm) or a known function

        } else if (this.p.is("-")) {
          this.p.next();
          this.parseSymbolicTerm_Pow(symterm);
          symterm.pushUnaryOperation("-");
        } else this.p.err("expected unary");
      }
    }]);

    return ParseCodeSym;
  }();

  var ParseIM = /*#__PURE__*/function () {
    function ParseIM(parent) {
      _classCallCheck(this, ParseIM);

      this.p = parent;
    } // inline_math =
    //   "$" { im_expr } "$";


    _createClass(ParseIM, [{
      key: "parseInlineMath",
      value: function parseInlineMath() {
        var html = '';
        this.p.terminal('$');
        html += ' \`';

        while (!this.p.is('$') && !this.p.is('§END')) {
          html += this.parseIM_Expr();
        }

        html += '\` ';
        this.p.terminal('$');
        this.p.q.html += ' <span style="font-size: 13pt;">' + html.replaceAll('\`\`', '') + '</span> ';
      } // im_expr =  /*similar to ASCII math*/
      //   im_list;

    }, {
      key: "parseIM_Expr",
      value: function parseIM_Expr() {
        return this.parseIM_List();
      } // im_list =
      //   im_assign { (","|":"|"->"|"|->") } im_assign;

    }, {
      key: "parseIM_List",
      value: function parseIM_List() {
        var html = this.parseIM_Assign(); //    comma           colon           right arrow      maps to

        while (this.p.is(',') || this.p.is(':') || this.p.is('->') || this.p.is('|->')) {
          var op = this.p.tk;
          this.p.next();
          html += ' ' + op + ' ' + this.parseIM_Assign();
        }

        return html;
      } // im_assign =
      //   im_other_binary_op "=" im_other_binary_op;

    }, {
      key: "parseIM_Assign",
      value: function parseIM_Assign() {
        var html = this.parseIM_OtherBinaryOp();

        while (this.p.is('=')) {
          this.p.next();
          html = html + ' = ' + this.parseIM_OtherBinaryOp();
        }

        return html;
      } // im_other_binary_op =
      //   im_relational { ("in"|"notin"|"uu"|"^^"|"vv"|"@") } im_relational;

    }, {
      key: "parseIM_OtherBinaryOp",
      value: function parseIM_OtherBinaryOp() {
        var html = this.parseIM_Relational(); //    element of       not element of      union            logical and      logical or       circ

        while (this.p.is('in') || this.p.is('notin') || this.p.is('uu') || this.p.is('^^') || this.p.is('vv') || this.p.is('@')) {
          var op = this.p.tk;
          this.p.next();
          html = html + ' ' + op + ' ' + this.parseIM_Relational();
        }

        return html;
      } // im_relational = 
      //   im_add { ("<"|"<="|">"|">="|"!=") im_add };

    }, {
      key: "parseIM_Relational",
      value: function parseIM_Relational() {
        var html = this.parseIM_Add();

        while (this.p.is('<') || this.p.is('<=') || this.p.is('>') || this.p.is('>=') || this.p.is('!=')) {
          var op = this.p.tk;
          this.p.next();
          html = html + ' ' + op + ' ' + this.parseIM_Add();
        }

        return html;
      } // im_add =
      //   im_mul { ("+"|"-") im_mul };

    }, {
      key: "parseIM_Add",
      value: function parseIM_Add() {
        var html = this.parseIM_Mul();

        while (this.p.is('+') || this.p.is('-')) {
          var op = this.p.tk;
          this.p.next();
          html = html + ' ' + op + ' ' + this.parseIM_Mul();
        }

        return html;
      } // im_mul =
      //   im_pow { ("*"|"/") im_pow };

    }, {
      key: "parseIM_Mul",
      value: function parseIM_Mul() {
        var html = this.parseIM_Pow();

        while (this.p.is('*') || this.p.is('/')) {
          var op = this.p.tk;
          this.p.next();
          html = html + ' ' + op + ' ' + this.parseIM_Pow();
        }

        return html;
      } // im_pow =
      //   im_unary { "^" im_unary };

    }, {
      key: "parseIM_Pow",
      value: function parseIM_Pow() {
        var html = this.parseIM_Unary();

        while (this.p.is('^')) {
          var op = this.p.tk;
          this.p.next();
          html = html + ' ' + op + ' ' + this.parseIM_Unary();
        }

        return html;
      } // im_unary = (
      //     im_input
      //   | "text" "(" { MISC } ")"
      //   | "augmented" "(" ID "|" ID ")"
      //   | ("sum"|"prod"|"lim"|"int") [ "_" expr ] [ "^" expr ]
      //   | "RR" | "ZZ" | "QQ" | "CC"
      //   | "oo" | "infty"
      //   | "equiv" | "mod"
      //   | "EE" | "AA"
      //   | "dx" | "dy" | "dz"
      //   | "bar" im_unary
      //   | "-" unary
      //   | " "
      //   | INT | FLOAT
      //   | ID
      //   | ID "[" (INT|":") "," (INT|":") "]"
      //   | "\"" ID "\""
      //   | "(" im_expr ")"
      //   | "{" { im_expr } "}"
      //   | "|"
      //   | "\"
      //   | "\\"
      //   | "..."
      //   | im_matrix
      // ) [ "!" | {"'"} ];

    }, {
      key: "parseIM_Unary",
      value: function parseIM_Unary() {
        var html = '';
        if (this.p.is('#')) html += '\`' + this.p.imInputParser.parseIM_Input() + '\`'; // '\`' ends and restarts math-jax env
        else if (this.p.is('text')) {
          this.p.next();
          this.p.terminal('(');
          html += ' \` ';

          while (!this.p.is(")") && !this.p.is("§EOF")) {
            html += this.p.tk;
            this.p.next();
          }

          html += ' \` ';
          this.p.terminal(')');
        } else if (this.p.is('augmented')) {
          this.p.next();
          this.p.terminal('(');
          var A = null,
              b = null;

          if (this.p.isIdent()) {
            // TODO: does not allow variable names with '_' yet
            if (this.p.tk in this.p.q.symbols && this.p.q.symbols[this.p.tk].type == symtype.T_MATRIX) A = this.p.q.symbols[this.p.tk].value;else this.p.err("expected a matrix");
            this.p.next();
          } else this.p.err("expected a matrix");

          this.p.terminal('|');

          if (this.p.isIdent()) {
            // TODO: does not allow variable names with '_' yet
            if (this.p.tk in this.p.q.symbols && this.p.q.symbols[this.p.tk].type == symtype.T_MATRIX) b = this.p.q.symbols[this.p.tk].value;else this.p.err("expected a column vector");
            this.p.next();
          } else this.p.err("expected a column vector");

          this.p.terminal(')'); // construct augmented matrix in ASCIIMATH (e.g. "((a,b,|,c),(d,e,|,f))")

          var m = SellLinAlg.mat_get_row_count(A);
          var n = SellLinAlg.mat_get_col_count(A);
          if (SellLinAlg.mat_get_col_count(b) != 1) this.p.err("expected a column vector");
          if (SellLinAlg.mat_get_row_count(b) != n) this.p.err("matrix rows and vector rows not matching");
          var augm = '(';

          for (var i = 0; i < m; i++) {
            augm += '(';

            for (var j = 0; j < n; j++) {
              augm += SellLinAlg.mat_get_element_value(A, i, j) + ",";
            }

            augm += '|,' + SellLinAlg.mat_get_element_value(b, i, 0);
            augm += ')';
            if (i < m - 1) augm += ',';
          }

          augm += ')';
          html += augm + ' '; // TODO: round parentheses vs brackets: must be configurable
        } else if (this.p.is('sum') || this.p.is('prod') || this.p.is('lim') || this.p.is('int')) {
          html += ' ' + this.p.tk;
          this.p.next();

          if (this.p.is('_')) {
            this.p.next();
            html += '_' + this.parseIM_Expr();
          }

          if (this.p.is('^')) {
            this.p.next();
            html += '^' + this.parseIM_Expr();
          }

          html += ' ';
        } else if (this.p.is('RR') || this.p.is('ZZ') || this.p.is('QQ') || this.p.is('CC')) {
          html += this.p.tk + " ";
          this.p.next();
        } else if (this.p.is('oo') || this.p.is('infty')) {
          // infinity
          html += this.p.tk + " ";
          this.p.next();
        } else if (this.p.is('equiv') || this.p.is('mod')) {
          html += this.p.tk + " ";
          this.p.next();
        } else if (this.p.is('EE') || this.p.is('AA')) {
          html += this.p.tk + " ";
          this.p.next();
          html += this.parseIM_Expr();
        } else if (this.p.is('dx') || this.p.is('dy') || this.p.is('dz')) {
          html += '\\ \\ ' + this.p.tk;
          this.p.next();
        } else if (this.p.is('bar')) {
          html += this.p.tk + " ";
          this.p.next();
          html += this.parseIM_Unary();
        } else if (this.p.is('-')) {
          this.p.next();
          html += '-';
          html += this.parseIM_Unary();
        } else if (this.p.is(' ')) {
          html += ' ';
          this.p.next();
        } else if (this.p.isNumber()) {
          html += this.p.tk;
          this.p.next();
        } else if (this.p.isIdent()) {
          var id = this.p.tk;
          this.p.next();

          while (this.p.tk == '_') {
            id += '_';
            this.p.next();

            if (this.p.isIdent() || this.p.isNumber()) {
              id += this.p.tk;
              this.p.next();
            }
          }

          if (id in this.p.q.symbols) {
            if (this.p.q.symbols[id].type == symtype.T_MATRIX && this.p.is("[")) {
              // submatrix
              var _i = 0,
                  _j = 0,
                  allRows = false,
                  allCols = false;
              this.p.next(); // row

              if (this.p.is(":")) {
                this.p.next();
                allRows = true;
              } else if (this.p.isInt()) {
                _i = parseInt(this.p.tk);
                this.p.next();
              } else this.p.err("expected integer for matrix row"); // separator


              this.p.terminal(","); // col

              if (this.p.is(":")) {
                this.p.next();
                allCols = true;
              } else if (this.p.isInt()) {
                _j = parseInt(this.p.tk);
                this.p.next();
              } else this.p.err("expected integer for matrix col"); // end


              this.p.terminal("]");
              var symbol = this.p.q.symbols[id];
              if (symbol.type != symtype.T_MATRIX) this.p.err("'" + id + "' is not a matrix");
              var first_row = allRows ? 0 : _i - 1;
              var last_row = allRows ? -1 : _i - 1;
              var first_col = allCols ? 0 : _j - 1;
              var last_col = allCols ? -1 : _j - 1;
              var submat = SellLinAlg.mat_submatrix(symbol.value, first_row, last_row, first_col, last_col);
              if (submat == null) this.p.err("invalid indices");
              html += submat.toString(); // TODO: toAsciiMath()! (requires symbol!)
            } else html += this.p.q.symbols[id].toAsciiMath();
          } else html += id;
        } else if (this.p.is('"')) {
          this.p.next();
          this.p.ident();
          var _id = this.p.id;

          while (this.p.tk == '_') {
            _id += '_';
            this.p.next();

            if (this.p.isIdent() || this.p.isNumber()) {
              _id += this.p.tk;
              this.p.next();
            }
          }

          html += _id;
          this.p.terminal('"');
        } else if (this.p.is('(')) {
          this.p.next();
          html += '(';

          while (!this.p.is(')') && !this.p.is("§EOF")) {
            html += this.parseIM_Expr();
          }

          this.p.terminal(')');
          html += ')';
        } else if (this.p.is('{')) {
          this.p.next();
          html += '{ ';

          while (!this.p.is("}") && !this.p.is("§EOF")) {
            html += this.parseIM_Expr();
          }

          this.p.terminal('}');
          html += ' }';
        } else if (this.p.is('|')) {
          this.p.next();
          html += '|';
        } else if (this.p.is('\\')) {
          // spacing
          this.p.next();
          html += '\\ \\ ';
        } else if (this.p.is('\\\\') || this.p.is('setminus')) {
          this.p.next();
          html += 'setminus';
        } else if (this.p.is('...')) {
          this.p.next();
          html += '... ';
        } else if (this.p.is('[') && this.p.is2('[') || this.p.is('(') && this.p.is2('(')) {
          html += this.parseIM_Matrix();
        } else if (this.p.is('[') || this.p.is(']')) {
          html += this.p.tk;
          this.p.next();

          while (!this.p.is("]") && !this.p.is("[") && !this.p.is("§EOF")) {
            html += this.parseIM_Expr();
          }

          if (this.p.is('[') || this.p.is(']')) {
            html += this.p.tk;
            this.p.next();
          } else this.p.err("expected '[' or ']'");
        } else this.p.err("expected unary, got '" + this.p.tk + "'"); // postfix

        if (this.p.is('!')) {
          this.p.next();
          html += '! ';
        }

        while (this.p.is("'")) {
          this.p.next();
          html += "'";
        }

        return html;
      } // im_matrix = 
      //     "["        "[" im_expr {"," im_expr} "]" 
      //          { "," "[" im_expr {"," im_expr} "]" } "]";
      //   | "("        "(" im_expr {"," im_expr} "]" 
      //          { "," "[" im_expr {"," im_expr} ")" } ")";

    }, {
      key: "parseIM_Matrix",
      value: function parseIM_Matrix() {
        // expecting  first2(IM_matrix) == [ "[", "[" ]
        //         or first2(IM_matrix) == [ "(", "(" ].
        // otherwise, we assume a parenthesized expression.
        var html = '';
        var p_open = ''; // '[' or '('

        var p_close = ''; // ']' or ')'

        if (this.p.is('[') && this.p.is2('[')) {
          p_open = '[';
          p_close = ']';
          this.p.next();
          html += p_open;
        } else if (this.p.is('(') && this.p.is2('(')) {
          p_open = '(';
          p_close = ')';
          this.p.next();
        } else this.p.err('expected [ or (');

        var cols = -1;
        var rows = 0;

        while (this.p.is(p_open) || this.p.is(',')) {
          if (rows > 0) {
            this.p.terminal(',');
            html += ',';
          }

          this.p.terminal(p_open);
          html += p_open;
          var col = 0;

          while (!this.p.is(p_close)) {
            if (col > 0) {
              this.p.terminal(',');
              html += ',';
            }

            html += this.parseIM_Expr();
            col++;
          }

          if (cols == -1) cols = col;else if (col != cols) this.p.err('matrix has different number of cols per row');
          this.p.terminal(p_close);
          html += p_close;
          rows++;
        }

        if (rows < 1 || cols < 1) this.p.err('matrix must have at least one row and one column');
        this.p.terminal(p_close);
        html += p_close;
        return html;
      }
    }]);

    return ParseIM;
  }();

  /******************************************************************************
   * SELL - SIMPLE E-LEARNING LANGUAGE                                          *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  function getHtmlChildElementRecursive(parentElement, childID) {
    for (var i = 0; i < parentElement.children.length; i++) {
      if (parentElement.children[i].id == childID) return parentElement.children[i];else if (parentElement.children[i].hasChildNodes()) {
        var e = getHtmlChildElementRecursive(parentElement.children[i], childID);
        if (e != null) return e;
      }
    }

    return null;
  }
  function sellLevenShteinDistance() {
    var str1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var str2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    // 'code' taken from: https://www.tutorialspoint.com/levenshtein-distance-in-javascript
    // TODO: copyright?????
    var track = Array(str2.length + 1).fill(null).map(function () {
      return Array(str1.length + 1).fill(null);
    });

    for (var i = 0; i <= str1.length; i += 1) {
      track[0][i] = i;
    }

    for (var j = 0; j <= str2.length; j += 1) {
      track[j][0] = j;
    }

    for (var _j = 1; _j <= str2.length; _j += 1) {
      for (var _i = 1; _i <= str1.length; _i += 1) {
        var indicator = str1[_i - 1] === str2[_j - 1] ? 0 : 1;
        track[_j][_i] = Math.min(track[_j][_i - 1] + 1, // deletion
        track[_j - 1][_i] + 1, // insertion
        track[_j - 1][_i - 1] + indicator);
      }
    }

    return track[str2.length][str1.length];
  }

  var MatrixInput = /*#__PURE__*/function () {
    function MatrixInput(question, input, m, n) {
      var wideInput = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var resizableRows = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      var resizableCols = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

      _classCallCheck(this, MatrixInput);

      this.question = null;
      this.input = null;
      this.m = 2;
      this.n = 2;
      this.wideInput = false;
      this.resizableRows = false;
      this.resizableCols = false;
      this.ELEMENT_TYPE_INPUT = 'input'; // TODO: MUST BE DEFINED AT ONE SINGLE LOCATION and NOT here!!

      this.ELEMENT_TYPE_SPAN = 'span';
      this.question = question;
      this.input = input;
      this.m = m;
      this.n = n;
      this.wideInput = wideInput;
      this.resizableRows = resizableRows;
      this.resizableCols = resizableCols;
    }

    _createClass(MatrixInput, [{
      key: "resize",
      value: function resize(diffM, diffN) {
        var oldM = this.m;
        var oldN = this.n;
        var oldValues = this.getStudentAnswer();
        this.m += diffM;
        this.n += diffN;
        this.m = this.m < 1 ? 1 : this.m;
        this.n = this.n < 1 ? 1 : this.n;
        this.updateHTML();

        for (var i = 0; i < this.m; i++) {
          for (var j = 0; j < this.n; j++) {
            if (i < oldM && j < oldN) this.setElementText(i, j, oldValues[i * oldN + j]);
          }
        }
      }
    }, {
      key: "getElementText",
      value: function getElementText(i, j) {
        var id = this.input.htmlElementId + '_' + i + '_' + j; // TODO: MUMIE!!

        var element = getHtmlChildElementRecursive(this.question.bodyHtmlElement, id);
        return element.value;
      }
    }, {
      key: "setElementText",
      value: function setElementText(i, j, text) {
        var id = this.input.htmlElementId + '_' + i + '_' + j; // TODO: MUMIE!!

        var element = getHtmlChildElementRecursive(this.question.bodyHtmlElement, id);
        element.value = text;
      }
    }, {
      key: "getStudentAnswer",
      value: function getStudentAnswer() {
        var s = [];

        for (var i = 0; i < this.m; i++) {
          for (var j = 0; j < this.n; j++) {
            var sij = this.getElementText(i, j);
            s.push(sij);
          }
        }

        return s;
      }
    }, {
      key: "setUnsetElementsToZero",
      value: function setUnsetElementsToZero() {
        for (var i = 0; i < this.m; i++) {
          for (var j = 0; j < this.n; j++) {
            var v = this.getElementText(i, j);

            if (v.length == 0) {
              this.setElementText(i, j, "0");
            }
          }
        }
      }
    }, {
      key: "updateHTML",
      value: function updateHTML() {
        var elementWidth = this.wideInput ? 20 : 4;
        var s = '';
        s += '<span>\n';
        s += '<table class="p-0 m-0" style="display:inline-block;border-spacing:0;border-collapse:collapse;">\n';
        s += '    <tr>\n';
        s += '        <td>\n';
        s += '            <table style="border-spacing:0;border-collapse:collapse;border-left:2px solid black;border-right:2px solid black;">\n';

        for (var i = 0; i < this.m; i++) {
          s += '                <tr>\n';
          if (i == 0) s += '                    <td style="border-top:2px solid black;"></td>\n';else if (i == this.m - 1) s += '                    <td style="border-bottom:2px solid black;"></td>\n';else s += '                    <td></td>\n';

          for (var j = 0; j < this.n; j++) {
            var id = this.input.htmlElementId + '_' + i + '_' + j;
            s += '                    <td>\n';
            s += '            <input type="text" id="' + id + '" size="' + elementWidth + '" placeholder=""/>\n';
            s += '                    </td>\n';
          }

          if (i == 0) s += '                    <td style="border-top:2px solid black;"></td>\n';else if (i == this.m - 1) s += '                    <td style="border-bottom:2px solid black;"></td>\n';else s += '<td></td>\n';
          s += '                </tr>\n';
        }

        s += '            </table>\n';
        s += '        </td>\n';

        if (this.resizableCols) {
          s += '        <td style="text-align:left">\n';
          s += '            <button class="matrix_size_button" style="font-size:18px;padding:0;border:none;background:none;" onclick="sellquiz.refreshMatrixDimensions(' + this.question.idx + ', \'' + this.input.htmlElementId + '\', 0, 1);">&nbsp;&#8853;</button>\n';
          s += '            <br/>\n';
          s += '            <button class="matrix_size_button" style="font-size:18px;padding:0;border:none;background:none;" onclick="sellquiz.refreshMatrixDimensions(' + this.question.idx + ', \'' + this.input.htmlElementId + '\', 0, -1);">&nbsp;&#8854;</button>\n';
          s += '        </td>\n';
        }

        s += '    </tr>\n';
        s += '    <tr>\n';

        if (this.resizableRows) {
          s += '    <td style="text-align:center">\n';
          s += '        <button class="matrix_size_button" style="font-size:18px;padding:0;border:none;background:none;" onclick="sellquiz.refreshMatrixDimensions(' + this.question.idx + ', \'' + this.input.htmlElementId + '\', 1, 0);">&#8853;</button>\n';
          s += '        &nbsp;\n';
          s += '        <button class="matrix_size_button" style="font-size:18px;padding:0;border:none;background:none;" onclick="sellquiz.refreshMatrixDimensions(' + this.question.idx + ', \'' + this.input.htmlElementId + '\', -1, 0);">&#8854;</button>\n';
          s += '    </td>\n';
        }

        s += '        <td></td>\n';
        s += '    </tr>\n';
        s += '</table>\n';
        s += '</span>\n';
        var element = getHtmlChildElementRecursive(this.question.bodyHtmlElement, this.input.htmlElementId);
        sellassert(element != null, "MatrixInput.updateHTML(): question body HTML element is not set.");
        element.innerHTML = s; //TODO: MUMIE !!! this.getElementByIdAndType(this.id, this.ELEMENT_TYPE_SPAN).innerHTML = s;
      }
    }]);

    return MatrixInput;
  }();

  var ParseIM_Input = /*#__PURE__*/function () {
    function ParseIM_Input(parent) {
      _classCallCheck(this, ParseIM_Input);

      this.p = parent;
    } // im_input =
    //   "#" [ "[" "diff" ID "]" ] ( 
    //       ID
    //     | "\"" (ID|INT) { "|" (ID|INT) } "\""    /* gap question text */
    //   );


    _createClass(ParseIM_Input, [{
      key: "parseIM_Input",
      value: function parseIM_Input() {
        var diffVar = '';
        var html = '';
        this.p.parseWhitespaces = false;
        this.p.parsingInlineCode = true; //let lex_backup = this.p.backupLexer();

        this.p.terminal('#');

        if (this.p.is("[")) {
          this.p.next(); // properties

          if (this.p.is("diff")) {
            this.p.next();

            while (this.p.is(' ')) {
              this.p.next();
            }

            if (this.p.isIdent()) {
              diffVar = this.p.tk;
              this.p.next();
            } else this.p.err("expected diff var");
          } else {
            this.p.err("unknown property '" + this.p.tk + "'");
          }

          this.p.terminal("]");
        }

        var sym = null,
            symId = '';

        if (this.p.is('"')) {
          this.p.next(); // gap question

          var gapTexts = []; // set of correct answers per gap

          var gapText = '';

          while (!this.p.is('"') && !this.p.is("§EOF")) {
            gapText += this.p.tk;
            this.p.next();
          }

          this.p.terminal('"');
          gapTexts.push(gapText);

          while (this.p.is("|")) {
            this.p.next();
            gapText = '';
            this.p.terminal('"');

            while (!this.p.is('"') && !this.p.is("§EOF")) {
              gapText += this.p.tk;
              this.p.next();
            }

            this.p.terminal('"');
            gapTexts.push(gapText);
          }

          symId = 'gap_' + this.p.createUniqueID();
          sym = new SellSymbol(symtype.T_STRING_LIST, gapTexts);
          this.p.q.solutionSymbols[symId] = sym;
        } else {
          this.p.codeParser.parseUnary();
          symId = 'sol' + this.p.createUniqueID();
          sym = this.p.q.stack.pop();
          this.p.q.lastParsedInputSymbol = sym;
          this.p.q.solutionSymbols[symId] = sym;
        }

        this.p.q.solutionSymbols[symId] = sym; // TODO: this is also done above!?!?!

        if (diffVar.length > 0) this.p.q.solutionSymbolsMustDiffFirst[symId] = diffVar; // TODO

        var inputWidth = 5;
        var isWideInput = false;
        var rows = 0,
            cols = 0;
        var input = new SellInput();
        input.htmlElementId = "sellquiz_input_" + symId;
        input.solutionVariableId = symId;
        input.htmlElementId_feedback = "sellquiz_feedback_" + symId;
        this.p.q.inputs.push(input);

        switch (sym.type) {
          case symtype.T_STRING:
          case symtype.T_STRING_LIST:
            // list := list of alternatives -> 1 box
            inputWidth += 10;
            input.htmlElementInputType = SellInputElementType.TEXTFIELD;

            if (this.p.generateInputFieldHtmlCode == false) {
              html += '$$' + input.htmlElementId;
            } else {
              html += ' <input type="text" value="" id="' + input.htmlElementId + '" size="' + inputWidth + '" placeholder=""> ';
              html += '<span id="' + input.htmlElementId_feedback + '"></span>';
            }

            break;

          case symtype.T_REAL:
          case symtype.T_FUNCTION:
            if (sym.type == symtype.T_FUNCTION) inputWidth += 10;
            input.htmlElementInputType = SellInputElementType.TEXTFIELD;

            if (this.p.generateInputFieldHtmlCode == false) {
              html += ' $$' + input.htmlElementId + ' ';
              html += '$$' + input.htmlElementId_feedback + ' ';
            } else {
              html += ' <input type="text" value="" id="' + input.htmlElementId + '" size="' + inputWidth + '" placeholder=""> ';
              html += '<span id="' + input.htmlElementId_feedback + '"></span>';
            }

            break;

          case symtype.T_COMPLEX:
            input.htmlElementInputType = SellInputElementType.COMPLEX_NUMBER;

            if (this.p.generateInputFieldHtmlCode == false) {
              html += ' $$' + input.htmlElementId + ' ';
              html += '$$' + input.htmlElementId_feedback + ' ';
            } else {
              // -- real part --
              html += '<input type="text" name="sell_input" value="" id="' + input.htmlElementId + '_real" size="' + inputWidth + '" placeholder=""> `+` '; // -- complex part --

              html += '<input type="text" name="sell_input" value="" id="' + input.htmlElementId + '_imag" size="' + inputWidth + '" placeholder=""> `i` '; // TODO: make i<->j configurable

              html += '<span id="' + input.htmlElementId_feedback + '"></span>';
            }

            break;

          case symtype.T_SET:
          case symtype.T_COMPLEX_SET:
            if (sym.type == symtype.T_COMPLEX_SET) inputWidth += 5;
            input.htmlElementInputType = SellInputElementType.VECTOR;
            input.vectorLength = sym.value.length;

            if (this.p.generateInputFieldHtmlCode == false) {
              html += ' $$' + input.htmlElementId + ' ';
              html += '$$' + input.htmlElementId_feedback + ' ';
            } else {
              html += '`{`';

              for (var i = 0; i < sym.value.length; i++) {
                if (i > 0) html += ' , ';
                html += ' <input type="text" name="sell_input" value="" id="' + input.htmlElementId + '_' + i + '" size="' + inputWidth + '" placeholder=""> ';
              }

              html += '`}`';
              html += '<span id="' + input.htmlElementId_feedback + '"></span>';
            }

            break;

          case symtype.T_MATRIX:
          case symtype.T_MATRIX_OF_FUNCTIONS:
            isWideInput = sym.type == symtype.T_MATRIX_OF_FUNCTIONS;

            if (sym.type == symtype.T_MATRIX) {
              rows = this.p.resizableRows ? 2 : SellLinAlg.mat_get_row_count(sym.value);
              cols = this.p.resizableCols ? 2 : SellLinAlg.mat_get_col_count(sym.value);
            } else {
              rows = this.p.resizableRows ? 2 : sym.value.m;
              cols = this.p.resizableCols ? 2 : sym.value.n;
            }

            input.htmlElementInputType = SellInputElementType.MATRIX;
            input.matrixInput = new MatrixInput(this.p.q, input, rows, cols, isWideInput, this.p.resizableRows, this.p.resizableCols); // create only a span here, since matrices are resizable and thus must be updatable

            if (this.p.generateInputFieldHtmlCode == false) {
              html += ' $$' + input.htmlElementId + ' ';
              html += '$$' + input.htmlElementId_feedback + ' ';
            } else {
              html += '<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="' + input.htmlElementId + '"></span>';
              html += '<span id="' + input.htmlElementId_feedback + '"></span>';
            }

            break;

          case symtype.T_JAVA_PROGRAMMING:
            inputWidth += 10;
            input.htmlElementInputType = SellInputElementType.JAVA_PROGRAMMING;

            if (this.p.generateInputFieldHtmlCode == false) {
              html += '$$' + input.htmlElementId;
            } else {
              html += '<div class="border p-0 m-0"><textarea class="form-control p-0" style="min-width: 100%;" id="' + input.htmlElementId + '" + rows="5"></textarea></div>';
              html += '<span id="' + input.htmlElementId_feedback + '"></span>';
            }

            break;

          default:
            this.p.err("unimplemented solution type '" + sym.type + "'");
        }

        if (this.p.debug) html += '<span class="text-warning">' + sym.toAsciiMath() + '</span>';
        this.p.parsingInlineCode = false;
        this.p.parseWhitespaces = true;
        return html;
      }
    }]);

    return ParseIM_Input;
  }();

  var ParseProg = /*#__PURE__*/function () {
    function ParseProg(parent) {
      _classCallCheck(this, ParseProg);

      this.p = parent;
    } // prog =
    //   ("JavaBlock"|"JavaMethod") ID "\n" "§CODE2_START" prog_assert "§CODE2_END";


    _createClass(ParseProg, [{
      key: "parseProg",
      value: function parseProg() {
        var type = "";
        if (this.p.is("JavaBlock")) type = "JavaBlock";else if (this.p.is("JavaMethod")) type = "JavaMethod";else this.p.err("unknown programming type " + this.p.tk);
        this.p.next();
        this.p.ident();
        var sym_id = this.p.id;
        this.p.terminal('§EOL');
        this.p.terminal('§CODE2_START');
        var assert_list = [];

        while (this.p.is("assert")) {
          assert_list.push(this.parseProgAssert());
        }

        this.p.terminal('§CODE2_END');
        this.p.q.symbols[sym_id] = new SellSymbol(symtype.T_JAVA_PROGRAMMING, {
          type: type,
          asserts: assert_list
        });
      } // prog_assert =
      //   "assert" "'" ANY "'" "\n";

    }, {
      key: "parseProgAssert",
      value: function parseProgAssert() {
        this.p.terminal("assert");
        this.p.terminal("'");
        this.p.parseWhitespaces = true;
        var assert_str = '';

        while (!this.p.is("'") && !this.p.is('§END')) {
          assert_str += this.p.tk;
          this.p.next();
        }

        this.p.terminal("'");
        this.p.parseWhitespaces = false;
        this.p.terminal('§EOL');
        return assert_str;
      }
    }]);

    return ParseProg;
  }();

  /******************************************************************************
   * SELL - SIMPLE E-LEARNING LANGUAGE                                          *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  var LANG_STR = {
    "feedback_syntaxerror_en": "Syntax error in '$'.",
    "feedback_syntaxerror_de": "Syntaxfehler in '$'.",
    "feedback_syntaxerror_or_invalid_variables_en": "Syntax error or invalid variables in '$'.",
    "feedback_syntaxerror_or_invalid_variables_de": "Syntaxfehler oder unzulässive Variablen in '$'.",
    "no_answer_selected_en": "No answer chosen.",
    "no_answer_selected_de": "Keine Antwort gewählt.",
    "not_yet_correct_en": "Not yet correct. Try again!",
    "not_yet_correct_de": "Noch nicht korrekt. Nochmal versuchen!",
    "dimensions_incorrect_en": "Dimensioned incorrectly!",
    "dimensions_incorrect_de": "Falsche Dimensionierung!",
    "hint_matrix_element_en": "Hint: Element ($i,$j) is incorrect!",
    "hint_matrix_element_de": "Tipp: Element ($i,$j) ist noch fehlerhaft!",
    "i_out_of_n_correct_en": "$i out of $n answers are correct",
    "i_out_of_n_correct_de": "$i von $n Antworten sind korrekt"
  };
  var checkmark = ' &#x2705; ';
  var crossmark = ' &#x274C; ';
  function GET_STR(key) {
    var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en";
    var complete_key = key + '_' + lang;
    sellassert(complete_key in LANG_STR, "GET_STR(..): unknown key " + complete_key);
    return '<span class="text-danger">' + LANG_STR[complete_key] + '</span>';
  }

  var Evaluate = /*#__PURE__*/function () {
    function Evaluate(parent) {
      _classCallCheck(this, Evaluate);

      this.selectedAnySingleChoiceOption = false;
      this.questionContainsSingleChoice = false;
      this.allMultipleChoiceAnswersAreCorrect = true;
      this.p = parent;
    } // TODO: replace asserts by error log!!


    _createClass(Evaluate, [{
      key: "setStudentAnswerManually",
      value: function setStudentAnswerManually(qidx, solutionVariableId, answerStr) {
        var q = this.p.getQuestionByIdx(qidx);
        if (q == null) return false;
        var input = null;

        for (var i = 0; i < q.inputs.length; i++) {
          if (q.inputs[i].solutionVariableId == solutionVariableId) {
            input = q.inputs[i];
            break;
          }
        }

        if (input == null) {
          sellassert(false, "setStudentAnswerManually(): could not find input element for given solution variable '" + solutionVariableId + "'");
        }

        switch (input.htmlElementInputType) {
          case SellInputElementType.TEXTFIELD:
            input.studentAnswer = [answerStr];
            break;

          default:
            sellassert(false, "setStudentAnswerManually(): UNIMPLEMENTED!");
            break;
        }

        return true;
      }
    }, {
      key: "getStudentAnswers",
      value: function getStudentAnswers(qidx) {
        var q = this.p.getQuestionByIdx(qidx);
        if (q == null) return false;
        if (q.bodyHtmlElement == null) sellassert(false, "getStudentAnswers(): bodyHtmlElement was not set");

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];
          var htmlElement = null;

          switch (input.htmlElementInputType) {
            case SellInputElementType.TEXTFIELD:
              htmlElement = getHtmlChildElementRecursive(q.bodyHtmlElement, input.htmlElementId);
              sellassert(htmlElement != null, "getStudentAnswers(): failed to get HTML child element: " + input.htmlElementId);
              input.studentAnswer = [htmlElement.value];
              break;

            case SellInputElementType.COMPLEX_NUMBER:
              // real part
              htmlElement = getHtmlChildElementRecursive(q.bodyHtmlElement, input.htmlElementId + '_real');
              sellassert(htmlElement != null, "getStudentAnswers(): failed to get HTML child element: " + input.htmlElementId);
              if (htmlElement.value.length == 0) htmlElement.value = "0";
              input.studentAnswer = [htmlElement.value]; // imaginay parg

              htmlElement = getHtmlChildElementRecursive(q.bodyHtmlElement, input.htmlElementId + '_imag');
              sellassert(htmlElement != null, "getStudentAnswers(): failed to get HTML child element: " + input.htmlElementId);
              if (htmlElement.value.length == 0) htmlElement.value = "0";
              input.studentAnswer.push(htmlElement.value);
              break;

            case SellInputElementType.CHECKBOX:
              htmlElement = getHtmlChildElementRecursive(q.bodyHtmlElement, input.htmlElementId);
              sellassert(htmlElement != null, "getStudentAnswers(): failed to get HTML child element: " + input.htmlElementId);
              input.studentAnswer = [htmlElement.checked ? "true" : "false"];
              break;

            case SellInputElementType.VECTOR:
              input.studentAnswer = [];

              for (var _i = 0; _i < input.vectorLength; _i++) {
                htmlElement = getHtmlChildElementRecursive(q.bodyHtmlElement, input.htmlElementId + '_' + _i);
                sellassert(htmlElement != null, "getStudentAnswers(): failed to get HTML child element: " + input.htmlElementId);

                if (htmlElement.value.length == 0) {
                  htmlElement.value = "0";
                }

                input.studentAnswer.push(htmlElement.value);
              }

              break;

            case SellInputElementType.MATRIX:
              input.matrixInput.setUnsetElementsToZero();
              input.studentAnswer = input.matrixInput.getStudentAnswer();
              break;

            case SellInputElementType.JAVA_PROGRAMMING:
              htmlElement = getHtmlChildElementRecursive(q.bodyHtmlElement, input.htmlElementId);
              sellassert(htmlElement != null, "getStudentAnswers(): failed to get HTML child element: " + input.htmlElementId);
              input.studentAnswer = [input.codeMirror.getValue()];
              break;

            default:
              sellassert(false, "getStudentAnswers(..): UNIMPLEMENTED HTML element type '" + input.htmlElementInputType + "'");
          }
        }

        return true;
      }
    }, {
      key: "displayFeedback",
      value: function displayFeedback(qidx) {
        var q = this.p.getQuestionByIdx(qidx);
        if (q == null) return false;
        if (q.bodyHtmlElement == null) sellassert(false, "displayFeedback(): bodyHtmlElement was not set");

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];
          var htmlElement = getHtmlChildElementRecursive(q.bodyHtmlElement, input.htmlElementId_feedback);
          sellassert(htmlElement != null, "displayFeedback(): failed to get HTML child element: " + input.htmlElementId);
          htmlElement.innerHTML = input.evaluationFeedbackStr;
        }

        return true;
      }
    }, {
      key: "getScore",
      value: function getScore(qidx) {
        // TODO: scoring is not yet weighted correctly etc...
        var q = this.p.questions[qidx];
        if (q == null) return -1;
        var score = 0.0;
        if (q.inputs.length == 0) return score;

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];
          if (input.correct) score += 1.0;
        }

        score /= q.inputs.length;
        return score;
      }
    }, {
      key: "evaluate",
      value: function evaluate(qidx) {
        this.selectedAnySingleChoiceOption = false;
        this.questionContainsSingleChoice = false;
        var q = this.p.questions[qidx];
        if (q == null) return false;
        this.checkIfAllMultipleChoiceAnswersAreCorrect(q);
        q.generalFeedbackStr = "";
        q.allAnswersCorrect = true;

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];
          var v = q.solutionSymbols[input.solutionVariableId];
          sellassert(v != null, "evaluate(): unknown solution symbol " + input.solutionVariableId + " known solution symbols: " + JSON.stringify(q.solutionSymbols));
          input.evaluationInProgress = false;

          switch (v.type) {
            case symtype.T_BOOL:
              this.evaluateBool(q, input, v);
              break;

            case symtype.T_REAL:
              this.evaluateReal(q, input, v);
              break;

            case symtype.T_COMPLEX:
              this.evaluateComplex(q, input, v);
              break;

            case symtype.T_FUNCTION:
              this.evaluateFunction(q, input, v);
              break;

            case symtype.T_STRING_LIST:
              this.evaluateStringList(q, input, v);
              break;

            case symtype.T_SET:
            case symtype.T_COMPLEX_SET:
              this.evaluateSet(q, input, v);
              break;

            case symtype.T_MATRIX:
            case symtype.T_MATRIX_OF_FUNCTIONS:
              this.evaluateMatrix(v.type == symtype.T_MATRIX_OF_FUNCTIONS, q, input, v);
              break;

            case symtype.T_JAVA_PROGRAMMING:
              input.evaluationInProgress = true;
              this.evaluateJavaProgramming(q, input, v);
              break;

            default:
              sellassert(false, "evaluate(): unimplemented math type: " + v.type.toString());
          }
        }

        if (this.questionContainsSingleChoice && this.selectedAnySingleChoiceOption == false) {
          q.generalFeedbackStr += GET_STR("no_answer_selected", this.p.language);
        }

        if (!this.allMultipleChoiceAnswersAreCorrect) {
          q.generalFeedbackStr += GET_STR("not_yet_correct", this.p.language);
        }

        return true;
      }
    }, {
      key: "isEvaluationReady",
      value: function isEvaluationReady(qidx) {
        var q = this.p.questions[qidx];
        if (q == null) return true;

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];
          if (input.evaluationInProgress) return false;
        }

        return true;
      }
    }, {
      key: "checkIfAllMultipleChoiceAnswersAreCorrect",
      value: function checkIfAllMultipleChoiceAnswersAreCorrect(question) {
        this.allMultipleChoiceAnswersAreCorrect = true;

        for (var i = 0; i < question.inputs.length; i++) {
          var input = question.inputs[i];

          if (input.solutionVariableId.includes('_mc_')) {
            var studentAnswer = input.studentAnswer[0] === "true";
            var solution = question.solutionSymbols[input.solutionVariableId].value;

            if (studentAnswer != solution) {
              this.allMultipleChoiceAnswersAreCorrect = false;
              break;
            }
          }
        }
      }
    }, {
      key: "evaluateBool",
      value: function evaluateBool(question, input, solutionVariable) {
        var studentAnswer = input.studentAnswer[0] === "true";
        input.correct = solutionVariable.value == studentAnswer;
        input.evaluationFeedbackStr = input.correct ? checkmark : crossmark;

        if (input.solutionVariableId.includes('_sc_')) {
          this.questionContainsSingleChoice = true; // if the input is a single-choice option, then only show feedback, if student
          // seleted this option:

          if (studentAnswer == false) input.evaluationFeedbackStr = "";
          if (studentAnswer == true) this.selectedAnySingleChoiceOption = true;
        } else if (input.solutionVariableId.includes('_mc_')) {
          // only give feedback, if all multiple-choice answers are correct
          if (this.allMultipleChoiceAnswersAreCorrect == false) input.evaluationFeedbackStr = "";
        }

        if (input.correct == false) question.allAnswersCorrect = false;
      }
    }, {
      key: "evaluateReal",
      value: function evaluateReal(question, input, solutionVariable) {
        var studentAnswerStr = input.studentAnswer[0].replaceAll(',', '.');
        var studentAnwser = 0;
        var feedback = '';

        try {
          studentAnwser = math__namespace.evaluate(studentAnswerStr);
          input.correct = math__namespace.abs(solutionVariable.value - studentAnwser) < solutionVariable.precision;
        } catch (e) {
          feedback += GET_STR("feedback_syntaxerror", this.p.language).replace("$", studentAnswerStr) + "&nbsp;&nbsp;";
          input.correct = false;
          question.allAnswersCorrect = false;
        }

        input.evaluationFeedbackStr = input.correct ? checkmark : crossmark;
        input.evaluationFeedbackStr += feedback;
        if (input.correct == false) question.allAnswersCorrect = false;
      }
    }, {
      key: "evaluateComplex",
      value: function evaluateComplex(question, input, solutionVariable) {
        // TODO: need property in SELL language, if trigonometric functions are allowed -> check here
        var studentAnswerStrReal = input.studentAnswer[0].replaceAll(',', '.');
        var studentAnswerStrImag = input.studentAnswer[1].replaceAll(',', '.');
        var studentAnwserReal = 0,
            studentAnswerImag = 0;
        var feedback = '';
        input.correct = true;

        try {
          studentAnwserReal = math__namespace.evaluate(studentAnswerStrReal);
        } catch (e) {
          input.correct = false;
          question.allAnswersCorrect = false;
          feedback += GET_STR("feedback_syntaxerror", this.p.language).replace("$", studentAnswerStrReal) + "&nbsp;&nbsp;";
        }

        try {
          studentAnswerImag = math__namespace.evaluate(studentAnswerStrImag);
        } catch (e) {
          input.correct = false;
          question.allAnswersCorrect = false;
          feedback += GET_STR("feedback_syntaxerror", this.p.language).replace("$", studentAnswerStrImag) + "&nbsp;&nbsp;";
        }

        if (input.correct) {
          var studentAnswer = math__namespace.complex(studentAnwserReal, studentAnswerImag);
          input.correct = math__namespace.abs(math__namespace.subtract(solutionVariable.value, studentAnswer)) < solutionVariable.precision;
        }

        input.evaluationFeedbackStr = input.correct ? checkmark : crossmark;
        input.evaluationFeedbackStr += feedback;
        if (input.correct == false) question.allAnswersCorrect = false;
      }
    }, {
      key: "evaluateStringList",
      value: function evaluateStringList(question, input, solutionVariable) {
        var studentAnswerStr = input.studentAnswer[0];
        var feedback = '';
        input.correct = true;

        for (var i = 0; i < solutionVariable.value.length; i++) {
          var sol_i = solutionVariable.value[i];
          var levDist = sellLevenShteinDistance(studentAnswerStr, sol_i);
          levDist = math__namespace.abs(levDist);
          var correct = sol_i.length <= 3 ? levDist == 0 : levDist <= 2;
          if (sol_i.length > 3 && levDist > 0 && levDist <= 2) feedback = '<span class="text-warning">' + sol_i + '</span>';else feedback = '';

          if (correct == false) {
            input.correct = false;
            question.allAnswersCorrect = false;
            break;
          }
        }

        input.evaluationFeedbackStr = input.correct ? checkmark : crossmark;
        input.evaluationFeedbackStr += feedback;
      }
    }, {
      key: "evaluateFunction",
      value: function evaluateFunction(question, input, solutionVariable) {
        var studentAnswerStr = input.studentAnswer[0].replaceAll(',', '.');
        var feedback = '';
        if (studentAnswerStr.length == 0) studentAnswerStr = "123456789123456789"; // if no answer is given, do not assume "0", since zero is often a valid answer

        if (input.solutionVariableId in question.solutionSymbolsMustDiffFirst) {
          var studentAnswer = new SellSymTerm();

          if (studentAnswer.importTerm(studentAnswerStr) == false) {
            question.allAnswersCorrect = false;
            input.correct = false;
            feedback += GET_STR("feedback_syntaxerror", this.p.language).replace("$", studentAnswerStr) + "&nbsp;&nbsp;";
            input.evaluationFeedbackStr = crossmark + feedback;
            return;
          }

          var diffVar = question.solutionSymbolsMustDiffFirst[input.solutionVariableId];
          studentAnswer = studentAnswer.derivate(diffVar);
          studentAnswerStr = studentAnswer.toString();
        }

        input.correct = solutionVariable.value.compareWithStringTerm(studentAnswerStr);

        if (input.correct == false) {
          question.allAnswersCorrect = false;

          if (solutionVariable.value.state === "syntaxerror") {
            feedback += GET_STR("feedback_syntaxerror_or_invalid_variables", this.p.language).replace("$", studentAnswerStr) + "&nbsp;&nbsp;";
          }
        }

        input.evaluationFeedbackStr = input.correct ? checkmark : crossmark;
        input.evaluationFeedbackStr += feedback;
      }
    }, {
      key: "evaluateSet",
      value: function evaluateSet(question, input, solutionVariable) {
        var studentAnswer = [];
        var n = solutionVariable.value.length;
        var feedback = '';

        for (var i = 0; i < n; i++) {
          var studentAnswerStr_i = input.studentAnswer[i].replaceAll(',', '.').replaceAll('j', 'i');
          var studentAnswer_i = 0;

          try {
            studentAnswer_i = math__namespace.evaluate(studentAnswerStr_i);
          } catch (e) {
            feedback += GET_STR("feedback_syntaxerror", this.p.language).replace("$", studentAnswerStr_i) + "&nbsp;&nbsp;";
          }

          studentAnswer.push(studentAnswer_i);
        }

        var num_ok = 0;

        for (var _i2 = 0; _i2 < n; _i2++) {
          var sol = solutionVariable.value[_i2].value;

          for (var j = 0; j < n; j++) {
            var user_sol = studentAnswer[j];
            var diff = math__namespace.abs(math__namespace.subtract(sol, user_sol));

            if (diff < solutionVariable.precision) {
              num_ok++;
              break;
            }
          }
        }

        input.correct = num_ok == n;

        if (num_ok < n) {
          question.allAnswersCorrect = false;
          var f = GET_STR("i_out_of_n_correct", this.p.language) + "&nbsp;&nbsp;";
          f = f.replace('$i', '' + num_ok);
          f = f.replace('$n', '' + n);
          feedback += f;
        }

        input.evaluationFeedbackStr = input.correct ? checkmark : crossmark;
        input.evaluationFeedbackStr += feedback;
      }
    }, {
      key: "evaluateMatrix",
      value: function evaluateMatrix(functionalElements, question, input, solutionVariable) {
        var m = 0,
            n = 0;

        if (functionalElements) {
          m = solutionVariable.value.m;
          n = solutionVariable.value.n;
        } else {
          m = SellLinAlg.mat_get_row_count(solutionVariable.value);
          n = SellLinAlg.mat_get_col_count(solutionVariable.value);
        }

        input.correct = true;
        var feedback = '';

        if (input.matrixInput.m != m || input.matrixInput.n != n) {
          input.correct = false;
          question.allAnswersCorrect = false;
          feedback += GET_STR("dimensions_incorrect", this.p.language) + "&nbsp;&nbsp;";
        }

        if (input.correct) {
          for (var i = 0; i < m; i++) {
            for (var j = 0; j < n; j++) {
              var k = i * n + j;
              var studentAnswerStr = input.studentAnswer[k].replaceAll(',', '.');
              var correct = true;

              if (functionalElements) {
                correct = solutionVariable.value.elements[k].compareWithStringTerm(studentAnswerStr);

                if (solutionVariable.value.state === "syntaxerror") {
                  input.correct = false;
                  question.allAnswersCorrect = false;
                  feedback += GET_STR("feedback_syntaxerror_or_invalid_variables", this.p.language).replace("$", studentAnswerStr) + "&nbsp;&nbsp;";
                  break;
                }
              } else {
                var studentAnswer = 0.0;

                try {
                  studentAnswer = math__namespace.evaluate(studentAnswerStr);
                } catch (e) {
                  input.correct = false;
                  question.allAnswersCorrect = false;
                  feedback += GET_STR("feedback_syntaxerror", this.p.language).replace("$", studentAnswerStr) + "&nbsp;&nbsp;";
                  break;
                }

                if (math__namespace.abs(studentAnswer - SellLinAlg.mat_get_element_value(solutionVariable.value, i, j)) > solutionVariable.precision) {
                  input.correct = false;
                  question.allAnswersCorrect = false;
                  break;
                }
              }

              if (!correct) {
                input.correct = false;
                question.allAnswersCorrect = false;
                var hint = GET_STR("hint_matrix_element", this.p.language);
                hint = hint.replaceAll('$i', '' + (i + 1));
                hint = hint.replaceAll('$j', '' + (j + 1));
                feedback += hint + "&nbsp;&nbsp;";
                break;
              }
            }

            if (input.correct == false) break;
          }
        }

        input.evaluationFeedbackStr = input.correct ? checkmark : crossmark;
        input.evaluationFeedbackStr += feedback;
      }
    }, {
      key: "evaluateJavaProgramming",
      value: function evaluateJavaProgramming(question, input, solutionVariable) {
        //console.log(solutionVariable.value)
        var task = {
          "type": solutionVariable.value["type"],
          "source": input.studentAnswer[0],
          "asserts": solutionVariable.value["asserts"]
        }; //let service_url = "http://localhost:8000/services/service-prog.php"; // TODO: MAKE URL CHANGABLE!!

        var service_url = "./services/service-prog.php"; // TODO: MAKE URL CONFIGURABLE!!
        // TODO: must forbid running twice!!!!!

        var feedback_htmlElement = getHtmlChildElementRecursive(question.bodyHtmlElement, input.htmlElementId_feedback);
        console.log(feedback_htmlElement);
        console.log(feedback_htmlElement.innerHTML);
        feedback_htmlElement.innerHTML = "<span class=\"text-danger\">bitte warten...</span>"; // TODO: use lang.ts!!!!

        $__namespace.ajax({
          type: "POST",
          url: service_url,
          data: {
            input: JSON.stringify(task)
          },
          success: function success(data) {
            data = JSON.parse(data);
            var status = data["status"];
            var message = data["msg"];
            input.correct = status === "ok";
            input.evaluationFeedbackStr = input.correct ? checkmark + " korrekt!" : crossmark; // TODO: use lang.ts!!!!
            //if(message.length > 0 && message[message.length-1] == "\n")
            //    message = message.substring(0, message.length-1);

            input.evaluationFeedbackStr += ' &nbsp; <code>' + message.replaceAll("\n", "<br/>") + '</code>';
            if (input.correct == false) question.allAnswersCorrect = false;
            input.evaluationInProgress = false;
          },
          error: function error(xhr, status, _error) {
            console.error(xhr); // TODO: error handling!
          }
        });
      }
    }]);

    return Evaluate;
  }();

  /******************************************************************************
   * SELL - SIMPLE E-LEARNING LANGUAGE                                          *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  // this file contains static images
  var check_symbol_svg = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmlld0JveD0iMCAwIDQ0OCA1MTIiCiAgIHZlcnNpb249IjEuMSIKICAgaWQ9InN2ZzgzNSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iY2hlY2stc3F1YXJlLnN2ZyIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMS4wLjEgKGM0OTdiMDNjLCAyMDIwLTA5LTEwKSI+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhODQxIj4KICAgIDxyZGY6UkRGPgogICAgICA8Y2M6V29yawogICAgICAgICByZGY6YWJvdXQ9IiI+CiAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9zdmcreG1sPC9kYzpmb3JtYXQ+CiAgICAgICAgPGRjOnR5cGUKICAgICAgICAgICByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIiAvPgogICAgICAgIDxkYzp0aXRsZT48L2RjOnRpdGxlPgogICAgICA8L2NjOldvcms+CiAgICA8L3JkZjpSREY+CiAgPC9tZXRhZGF0YT4KICA8ZGVmcwogICAgIGlkPSJkZWZzODM5IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBvYmplY3R0b2xlcmFuY2U9IjEwIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwIgogICAgIGd1aWRldG9sZXJhbmNlPSIxMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTgxNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMTI4IgogICAgIGlkPSJuYW1lZHZpZXc4MzciCiAgICAgc2hvd2dyaWQ9ImZhbHNlIgogICAgIGlua3NjYXBlOnpvb209IjEuNDkxMDcxNCIKICAgICBpbmtzY2FwZTpjeD0iMjI0IgogICAgIGlua3NjYXBlOmN5PSIyNTYiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjIzIgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjAiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ic3ZnODM1IiAvPgogIDxwYXRoCiAgICAgZD0iTTQwMCAzMkg0OEMyMS40OSAzMiAwIDUzLjQ5IDAgODB2MzUyYzAgMjYuNTEgMjEuNDkgNDggNDggNDhoMzUyYzI2LjUxIDAgNDgtMjEuNDkgNDgtNDhWODBjMC0yNi41MS0yMS40OS00OC00OC00OHptMCA0MDBINDhWODBoMzUydjM1MnptLTM1Ljg2NC0yNDEuNzI0TDE5MS41NDcgMzYxLjQ4Yy00LjcwNSA0LjY2Ny0xMi4zMDMgNC42MzctMTYuOTctLjA2OGwtOTAuNzgxLTkxLjUxNmMtNC42NjctNC43MDUtNC42MzctMTIuMzAzLjA2OS0xNi45NzFsMjIuNzE5LTIyLjUzNmM0LjcwNS00LjY2NyAxMi4zMDMtNC42MzcgMTYuOTcuMDY5bDU5Ljc5MiA2MC4yNzcgMTQxLjM1Mi0xNDAuMjE2YzQuNzA1LTQuNjY3IDEyLjMwMy00LjYzNyAxNi45Ny4wNjhsMjIuNTM2IDIyLjcxOGM0LjY2NyA0LjcwNiA0LjYzNyAxMi4zMDQtLjA2OCAxNi45NzF6IgogICAgIGlkPSJwYXRoODMzIiAvPgo8L3N2Zz4K";

  var SellInputElementType;

  (function (SellInputElementType) {
    SellInputElementType["UNKNOWN"] = "unknown";
    SellInputElementType["TEXTFIELD"] = "textfield";
    SellInputElementType["COMPLEX_NUMBER"] = "complex_number";
    SellInputElementType["CHECKBOX"] = "checkbox";
    SellInputElementType["VECTOR"] = "vector";
    SellInputElementType["MATRIX"] = "matrix";
    SellInputElementType["JAVA_PROGRAMMING"] = "java_programming";
  })(SellInputElementType || (SellInputElementType = {}));

  var SellInput = function SellInput() {
    _classCallCheck(this, SellInput);

    this.htmlElementId = "";
    this.htmlElementInputType = SellInputElementType.UNKNOWN;
    this.htmlElementId_feedback = "";
    this.solutionVariableId = ""; //solutionVariableMathtype: symtype = symtype.T_UNKNOWN;
    // linearized input: one element for scalars, n elemens for vectors, m*n elements for matrices (row-major)

    this.studentAnswer = [];
    this.evaluationFeedbackStr = "";
    this.correct = false; // only used for matrix based mathtypes

    this.matrixInput = null; // only used for vector based mathtypes

    this.vectorLength = 1; // evaluation of e.g. programming tasks is done asynchronesouly.
    // As long as the evaluation is ongoing, evaluationInProgress is set true.

    this.evaluationInProgress = false;
    this.codeMirror = null; // IDE instance; only used for programming tasks
  };
  var SellQuestion = function SellQuestion() {
    _classCallCheck(this, SellQuestion);

    this.idx = 0;
    this.src = '';
    this.html = '';
    this.titleHtml = '';
    this.bodyHtml = '';
    this.bodyHtmlElement = null;
    this.symbols = {};
    this.solutionSymbols = {};
    this.solutionSymbolsMustDiffFirst = {};
    this.lastParsedInputSymbol = null;
    this.stack = [];
    this.inputs = [];
    this.generalFeedbackStr = "";
    this.allAnswersCorrect = false; // TODO: move parse method and other methods here
  };
  var SellQuiz = /*#__PURE__*/function () {
    function SellQuiz() {

      _classCallCheck(this, SellQuiz);

      // subclases
      this.evaluate = null;
      this.textParser = null;
      this.codeParser = null;
      this.codeSymParser = null;
      this.imParser = null;
      this.imInputParser = null;
      this.progParser = null;
      this.ELEMENT_TYPE_INPUT = 'input';
      this.ELEMENT_TYPE_SPAN = 'span'; // preferences

      this.debug = false;
      this.log = '';
      this.language = 'en';
      this.generateInputFieldHtmlCode = true; // questions

      this.questions = [];
      this.q = null; // current question

      this.qidx = 0; // current question index

      this.html = '';
      this.variablesJsonStr = ''; // TODO!!
      // lexer (remark: if attributes are changed, then methods backupLexer,
      //        and replayLexer must also be changed)

      this.tokens = [];
      this.tk = '';
      this.tk2 = '';
      this.tk_line = 0;
      this.tk_col = 0;
      this.tkIdx = 0;
      this.id = ''; // parsing states

      this.parseWhitespaces = false;
      this.parsingInlineCode = false; // true while parsing solution code after '#'
      // style states

      this.isBoldFont = false;
      this.isItalicFont = false;
      this.isItemize = false;
      this.isItemizeItem = false;
      this.singleMultipleChoiceFeedbackHTML = ''; // written at end of line
      // matrix inputs
      //matrixInputs: Array<SellMatrixInput> = [];

      this.resizableRows = false;
      this.resizableCols = false; // unique id counter

      this.uniqueIDCtr = 0;
      this.editButton = false; // instantiate evaluation class

      this.evaluate = new Evaluate(this); // instantiate parser classes

      this.textParser = new ParseText(this);
      this.codeParser = new ParseCode(this);
      this.codeSymParser = new ParseCodeSym(this);
      this.imParser = new ParseIM(this);
      this.imInputParser = new ParseIM_Input(this);
      this.progParser = new ParseProg(this);
    } // TODO:


    _createClass(SellQuiz, [{
      key: "createIDE",
      value: function createIDE(sellInput, htmlElement) {
        // dev info: the CodeMirror editor is not included here directly for two reasons:
        //  (a.) many users will use SELL without programming questions
        //  (b.) CodeMirror can not be used in combination with node.js (DOM-environment not present)
        console.log("ERROR: Obviously your quiz includes a programming task. Please also include sellquiz.ide.min.js in your HTML file");
      }
    }, {
      key: "importQuestions",
      value: function importQuestions(sellCode) {
        sellCode = sellCode.split('STOP')[0];
        var sellCodeLines = sellCode.split("\n");
        var code = '';
        var codeStartRow = 0;

        for (var i = 0; i < sellCodeLines.length; i++) {
          var line = sellCodeLines[i];

          if (line.startsWith("%%%")) {
            if (!this.importQuestion(code, codeStartRow)) return false;
            code = '';
            codeStartRow = i + 1;
          } else {
            code += line + '\n';
          }
        }

        if (!this.importQuestion(code, codeStartRow)) return false; // TODO:

        /*if(this.environment == "moodle") {
            for(let i=0; i<this.questions.length; i++) {
                let q = this.questions[i];
                this.variablesJsonStr = JSON.stringify({"symbols":q.symbols, "solutionSymbols":q.solutionSymbols}); // TODO: overwritten for every question!!
                let bp = 1337;
            }
        }*/

        return true;
      }
    }, {
      key: "importQuestion",
      value: function importQuestion(src) {
        var codeStartRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.resizableRows = false;
        this.resizableCols = false;
        this.tokens = [];
        this.tk = '';
        this.tk_line = 0;
        this.tk_col = 0;
        this.tk2 = ''; // look ahead 2

        this.tkIdx = 0;
        this.id = ''; // last identifier

        this.qidx = this.questions.length;
        this.q = new SellQuestion();
        this.q.idx = this.qidx;
        this.q.src = src;
        this.questions.push(this.q);
        var lines = src.split('\n'); //let indent1_last = false;
        //let indent2_last = false;

        var last_indent = 0;
        var code_block = false; // inline code (NOT to be confused with SELL-code)

        for (var i = 0; i < lines.length; i++) {
          if (!code_block && lines[i].startsWith('```')) code_block = true; //let indent2 = lines[i].startsWith('\t\t') || lines[i].startsWith('        ');
          //let indent1 = lines[i].startsWith('\t') || lines[i].startsWith('    ');
          //if (indent2)
          //    indent1 = false;

          var indent = 0;
          if (lines[i].startsWith('\t\t') || lines[i].startsWith('        ')) indent = 2;else if (lines[i].startsWith('\t') || lines[i].startsWith('    ')) indent = 1;
          var line_str = lines[i].split('%')[0]; // remove comments

          if (line_str.length == 0) // empty line
            continue;
          var lineTokens = Lexer.tokenize(line_str);
          if (lineTokens.length == 0) continue;
          lineTokens.push(new SellToken('§EOL', i + 1, -1)); // end of line

          if (!code_block) {
            /*if (!indent1 && indent1_last)
                this.tokens.push(new SellToken('§CODE_END', i + 1, -1));
            if (indent1 && !indent1_last)
                this.tokens.push(new SellToken('§CODE_START', i + 1, -1));*/
            if (last_indent == 0 && indent == 1) this.tokens.push(new SellToken('§CODE_START', i + 1, -1));else if (last_indent == 0 && indent == 2) {
              this.tokens.push(new SellToken('§CODE_START', i + 1, -1));
              this.tokens.push(new SellToken('§CODE2_START', i + 1, -1));
            } else if (last_indent == 1 && indent == 2) this.tokens.push(new SellToken('§CODE2_START', i + 1, -1));else if (last_indent == 2 && indent == 1) this.tokens.push(new SellToken('§CODE2_END', i + 1, -1));else if (last_indent == 2 && indent == 0) {
              this.tokens.push(new SellToken('§CODE2_END', i + 1, -1));
              this.tokens.push(new SellToken('§CODE_END', i + 1, -1));
            } else if (last_indent == 1 && indent == 0) this.tokens.push(new SellToken('§CODE_END', i + 1, -1));
          }

          for (var j = 0; j < lineTokens.length; j++) {
            this.tokens.push(lineTokens[j]);
            this.tokens[this.tokens.length - 1].line = codeStartRow + i + 1;
          } //indent1_last = indent1;
          //indent2_last = indent2;


          last_indent = indent;
          if (code_block && lines[i].endsWith('```')) code_block = false;
        }

        this.tokens.push(new SellToken('§END', -1, -1)); //console.log(this.tokens);
        //this.helper.printTokenList(this.tokens);

        this.tkIdx = 0;
        this.next();

        try {
          this.parse();
        } catch (e) {
          this.log += e + '\n';
          this.log += 'Error: compilation failed';
          return false;
        }

        if (this.tk !== '§END') this.err('Error: remaining tokens: "' + this.tk + '"...');
        this.log += '... compilation succeeded!\n'; // --- permutate patterns '§['...']§' (shuffles single/multiple choice answers) ---
        // TODO: does NOT work for multiple groups of multiple-choice/single-choice

        var options = [];
        var n = this.q.html.length;
        var tmpHtml = ''; // fill options-array and replace occurring patterns '§['...']§' by
        // '§i', with i := index of current option (0<=i<k, with  k   the total
        // number of options)

        for (var _i = 0; _i < n; _i++) {
          var ch = this.q.html[_i];
          var ch2 = _i + 1 < n ? this.q.html[_i + 1] : '';

          if (ch == '§' && ch2 == '[') {
            tmpHtml += '§' + options.length;
            options.push('');

            for (var _j = _i + 2; _j < n; _j++) {
              ch = this.q.html[_j];
              ch2 = _j + 1 < n ? this.q.html[_j + 1] : '';

              if (ch == ']' && ch2 == '§') {
                _i = _j + 1;
                break;
              }

              options[options.length - 1] += ch;
            }
          } else tmpHtml += ch;
        } // shuffle options


        var k = options.length;

        for (var l = 0; l < k; l++) {
          var _i2 = Lexer.randomInt(0, k);

          var _j2 = Lexer.randomInt(0, k);

          var tmp = options[_i2];
          options[_i2] = options[_j2];
          options[_j2] = tmp;
        } // reconstruct question-html


        for (var _l = 0; _l < k; _l++) {
          tmpHtml = tmpHtml.replace('§' + _l, options[_l]);
        }

        this.q.html = tmpHtml; // --- set HTML ---

        this.html += this.q.html + '\n\n';
        return true;
      }
    }, {
      key: "backupQuestion",
      value: function backupQuestion(questionID) {
        var q = this.getQuestionByIdx(questionID);
        if (q == null) return null;
        var backup = {}; // source and generated HTML

        backup["source_code"] = q.src;
        backup["title_html"] = q.titleHtml;
        backup["body_html"] = q.bodyHtml; // variables

        backup["variables"] = [];

        for (var symid in q.symbols) {
          backup["variables"].push(q.symbols[symid].exportDictionary(symid));
        }

        backup["solution_variables"] = [];

        for (var _symid in q.solutionSymbols) {
          backup["solution_variables"].push(q.solutionSymbols[_symid].exportDictionary(_symid));
        } // TODO: mustDiffFrist, ....
        // input fields


        backup["input_fields"] = [];

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];
          var f = {};
          f["element_type"] = input.htmlElementInputType;
          f["element_id"] = input.htmlElementId;
          f["element_id__feedback"] = input.htmlElementId_feedback;
          f["correct"] = input.correct;
          f["feedback_message"] = input.evaluationFeedbackStr;
          f["student_answer_string"] = input.studentAnswer;
          f["solution_variable_id"] = input.solutionVariableId;
          backup["input_fields"].push(f);
        } // global evaluation feedback


        backup["general_feedback"] = {};
        backup["general_feedback"]["all_answers_correct"] = q.allAnswersCorrect;
        backup["general_feedback"]["feedback_message"] = q.generalFeedbackStr; // stringify

        return JSON.stringify(backup, null, 4);
      }
    }, {
      key: "getQuestionInputFields",
      value: function getQuestionInputFields(questionID) {
        var inputFields = [];
        var backupStr = this.backupQuestion(questionID);
        var backup = JSON.parse(backupStr);

        for (var i = 0; i < backup["input_fields"].length; i++) {
          inputFields.push({
            "element_id": backup["input_fields"][i]["element_id"],
            "element_type": backup["input_fields"][i]["element_type"],
            "solution_variable_id": backup["input_fields"][i]["solution_variable_id"]
          });
        }

        return inputFields;
      }
    }, {
      key: "createQuestionFromBackup",
      value: function createQuestionFromBackup(backupStr) {
        var backup = JSON.parse(backupStr); // TODO: check, if backup string is consistent

        var q = new SellQuestion();
        q.idx = this.questions.length; // source and generated HTML

        q.src = backup["source_code"];
        q.titleHtml = backup["title_html"];
        q.bodyHtml = backup["body_html"]; // variables

        q.symbols = {};

        for (var i = 0; i < backup["variables"].length; i++) {
          var v = backup["variables"][i];
          var sym = new SellSymbol();
          sym.importDictionary(v);
          q.symbols[v["id"]] = sym;
        }

        q.solutionSymbols = {};

        for (var _i3 = 0; _i3 < backup["solution_variables"].length; _i3++) {
          var _v = backup["solution_variables"][_i3];

          var _sym = new SellSymbol();

          _sym.importDictionary(_v);

          q.solutionSymbols[_v["id"]] = _sym;
        } // input fields


        q.inputs = [];

        for (var _i4 = 0; _i4 < backup["input_fields"].length; _i4++) {
          var input = new SellInput();
          var f = backup["input_fields"][_i4];
          input.htmlElementInputType = f["element_type"];
          input.htmlElementId = f["element_id"];
          input.htmlElementId_feedback = f["element_id__feedback"];
          input.correct = f["correct"];
          input.evaluationFeedbackStr = f["feedback_message"];
          input.studentAnswer = f["student_answer_string"];
          input.solutionVariableId = f["solution_variable_id"];
          q.inputs.push(input);
        } // global evaluation feedback


        q.allAnswersCorrect = backup["general_feedback"]["all_answers_correct"];
        q.generalFeedbackStr = backup["general_feedback"]["feedback_message"]; // push question and return index

        this.questions.push(q);
        return q.idx;
      }
    }, {
      key: "getElementByIdAndType",
      value: function getElementByIdAndType(id, type) {
        // TODO:!!!!!

        /*if (this.environment == "mumie") {
            // https://www.integral-learning.de/platform/
            let inputField;
            inputField = Array.from(document.getElementsByTagName(type))
                .filter((inputFields) => inputFields.id === id)
                .find((inputFields) => inputFields.offsetParent !== null);
            return inputField ? inputField : document.getElementById(id);
        } else {
            // standalone version
            return document.getElementById(id);
        }*/
        return document.getElementById(id);
      }
    }, {
      key: "backupLexer",
      value: function backupLexer() {
        return {
          'tk': this.tk,
          'tk_line': this.tk_line,
          'tk_col': this.tk_col,
          'tk2': this.tk2,
          'tkIdx': this.tkIdx,
          'id': this.id
        };
      }
    }, {
      key: "replayLexer",
      value: function replayLexer(lexState) {
        this.tk = lexState['tk'];
        this.tk_line = lexState['tk_line'];
        this.tk_col = lexState['tk_col'];
        this.tk2 = lexState['tk2'];
        this.tkIdx = lexState['tkIdx'];
        this.id = lexState['id'];
      }
    }, {
      key: "createUniqueID",
      value: function createUniqueID() {
        return "ID" + this.uniqueIDCtr++;
      }
    }, {
      key: "updateMatrixInputs",
      value: function updateMatrixInputs(questionID) {
        var q = this.getQuestionByIdx(questionID);
        if (q == null) return false;

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];
          if (input.matrixInput != null) // TODO: better compare input.htmlElementInputType??
            input.matrixInput.updateHTML();
        }

        return true;
      }
    }, {
      key: "createProgrammingTaskEditors",
      value: function createProgrammingTaskEditors(questionID) {
        var q = this.getQuestionByIdx(questionID);
        if (q == null) return false;

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];

          if (input.htmlElementInputType == SellInputElementType.JAVA_PROGRAMMING) {
            var textarea = getHtmlChildElementRecursive(q.bodyHtmlElement, input.htmlElementId);
            this.createIDE(input, textarea, 'java', 150); // TODO: make height adjustable
          }
        }

        return true;
      }
    }, {
      key: "updateMatrixDims",
      value: function updateMatrixDims(questionID, htmlElementId, deltaRows, deltaCols) {
        var q = this.getQuestionByIdx(questionID);
        if (q == null) return false;

        for (var i = 0; i < q.inputs.length; i++) {
          var input = q.inputs[i];
          if (input.matrixInput != null && input.htmlElementId == htmlElementId) input.matrixInput.resize(deltaRows, deltaCols);
        }

        return true;
      }
    }, {
      key: "next",
      value: function next() {
        // look-ahead 1
        if (this.tkIdx >= this.tokens.length) {
          this.tk = '§END';
          this.tk_line = -1;
          this.tk_col = -1;
        } else {
          this.tk = this.tokens[this.tkIdx].str;
          this.tk_line = this.tokens[this.tkIdx].line;
          this.tk_col = this.tokens[this.tkIdx].col;
        } // look-ahead 2


        if (this.tkIdx + 1 >= this.tokens.length) this.tk2 = '§END';else this.tk2 = this.tokens[this.tkIdx + 1].str;
        this.tkIdx++;
        if (!this.parseWhitespaces && this.tk === ' ') this.next(); // lexer hack for parsing inline code: e.g. ['a','_','b'] -> ['a_b']

        if (this.parsingInlineCode && Lexer.isIdentifier(this.tk)) {
          while (this.parsingInlineCode && this.tkIdx < this.tokens.length - 1 && this.tk !== '§END' && (this.tokens[this.tkIdx].str === '_' || Lexer.isIdentifier(this.tokens[this.tkIdx].str) || Lexer.isInteger(this.tokens[this.tkIdx].str))) {
            this.tk += this.tokens[this.tkIdx].str;
            this.tk_line = this.tokens[this.tkIdx].line;
            this.tk_col = this.tokens[this.tkIdx].col;
            this.tkIdx++;
          }
        }

        if (!this.parseWhitespaces && this.tk === ' ') this.next();
      }
    }, {
      key: "err",
      value: function err(msg) {
        throw 'Error:' + this.tk_line + ':' + this.tk_col + ': ' + msg;
      }
    }, {
      key: "terminal",
      value: function terminal(t) {
        if (this.tk === t) this.next();else {
          if (t == "§EOL") this.err("expected linebreak, got '" + this.tk + "'");else this.err("expected '" + t + "', got '" + this.tk.replace('§EOL', 'linebreak') + "'");
        }
      }
    }, {
      key: "ident",
      value: function ident() {
        if (this.isIdent()) {
          this.id = this.tk;
          this.next();
        } else this.err("expected identifier");
      }
    }, {
      key: "isIdent",
      value: function isIdent() {
        return Lexer.isIdentifier(this.tk);
      }
    }, {
      key: "isNumber",
      value: function isNumber() {
        return !isNaN(this.tk);
      }
    }, {
      key: "isInt",
      value: function isInt() {
        return Lexer.isInteger(this.tk);
      }
    }, {
      key: "is",
      value: function is(s) {
        return this.tk === s;
      }
    }, {
      key: "is2",
      value: function is2(s) {
        return this.tk2 === s;
      }
    }, {
      key: "isNumberInt",
      value: function isNumberInt(v) {
        return Math.abs(v - Math.round(v)) < 1e-6;
      }
    }, {
      key: "pushSym",
      value: function pushSym(type, value) {
        var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-9;
        this.q.stack.push(new SellSymbol(type, value, precision));
      }
    }, {
      key: "charToHTML",
      value: function charToHTML(c) {
        switch (c) {
          case '§EOL':
            return '<br/>\n';

          default:
            return c;
        }
      } // sell = 
      //   title { code | text };

    }, {
      key: "parse",
      value: function parse() {
        this.textParser.parseTitle();
        this.q.html = "";

        while (!this.is('§END')) {
          if (this.is("§CODE_START")) this.codeParser.parseCode();else this.textParser.parseText();
        }

        this.q.bodyHtml = this.q.html;
        this.createHighLevelHTML();
      }
    }, {
      key: "createHighLevelHTML",
      value: function createHighLevelHTML() {
        // create high-level HTML:
        this.q.html = '<div id="sell_question_html_element_' + this.q.idx + '" class="card">\n';
        this.q.html += '<div class="card-header">\n';
        this.q.html += '    <h5 class="card-title m-0">' + this.q.titleHtml + '</h5>\n';
        this.q.html += '    <a name="question-' + (this.questions.length - 1) + '"></a>\n';
        this.q.html += '</div>\n';
        this.q.html += '<div class="card-body p-4">\n'; // ** begin body        

        this.q.html += this.q.bodyHtml;
        this.q.html += '</div>\n'; // ** end body (begins in keyword 'TITLE')
        // ** footer:

        this.q.html += '<div class="card-footer bg-white pl-4 pt-2 pb-1 m-0">';
        this.q.html += '<span>'; // submit button

        this.q.html += '<input type="image" id="button-evaluate" onclick="sellquiz.autoEvaluateQuiz(' + this.qidx + ', \'sell_question_html_element_' + this.q.idx + '\');" height="28px" src=\"' + check_symbol_svg + '\" title="evaluate"></input>'; // edit button

        if (this.editButton) {
          // TODO
          this.q.html += '&nbsp;&nbsp;<button type="button" class="btn btn-link" onclick="editSellQuestion(' + this.qidx + ')">edit</button>';
        } // general feedback


        this.q.html += '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="general_feedback"></span>'; // end

        this.q.html += '</span>';
        this.q.html += '</div>'; // *** end of card-footer

        this.q.html += '</div>\n'; // *** end of card

        this.q.html += '<br/>';
      }
    }, {
      key: "getQuestionByIdx",
      value: function getQuestionByIdx(idx) {
        if (idx < 0 || idx >= this.questions.length) return null;
        return this.questions[idx];
      }
    }, {
      key: "enableInputFields",
      value: function enableInputFields(questionID) {
        var enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var q = this.getQuestionByIdx(questionID);
        if (q == null) return false;
        if (q.bodyHtmlElement == null) sellassert(false, "enableInputFields(): q.bodyHtmlElement was not set");

        for (var i = 0; i < q.inputs.length; i++) {
          var element = getHtmlChildElementRecursive(q.bodyHtmlElement, q.inputs[i].htmlElementId);
          element.disabled = !enable;
        }

        return true;
      }
    }]);

    return SellQuiz;
  }(); // end of class Sell

  /******************************************************************************
   * SELL - SIMPLE E-LEARNING LANGUAGE                                          *
   *                                                                            *
   * Copyright (c) 2019-2021 TH Köln                                            *
   * Author: Andreas Schwenk, contact@compiler-construction.com                 *
   *                                                                            *
   * Partly funded by: Digitale Hochschule NRW                                  *
   * https://www.dh.nrw/kooperationen/hm4mint.nrw-31                            *
   *                                                                            *
   * GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007                         *
   *                                                                            *
   * This library is licensed as described in LICENSE, which you should have    *
   * received as part of this distribution.                                     *
   *                                                                            *
   * This software is distributed on "AS IS" basis, WITHOUT WARRENTY OF ANY     *
   * KIND, either impressed or implied.                                         *
   ******************************************************************************/
  var sellQuizInst = new SellQuiz();
  /**
   * Remove all questions.
   */

  function reset() {
    sellQuizInst = new SellQuiz();
  }
  /**
   * Creates a quiz including HTML control elements. This function can be used for a trivial integration of a stand-alone SELL quiz into a website. WARNING: do not mix using this high-level function and low-level functions.
   * @param sellCode SELL source code of one or multiple questions (divided by a line equal to %%%)
   * @param htmlDivElement HTML element that will contain all questions.
   * @returns Success.
   */


  function autoCreateQuiz(sellCode, htmlDivElement) {
    if (sellQuizInst.importQuestions(sellCode) == false) return false;
    htmlDivElement.innerHTML = sellQuizInst.html;

    for (var i = 0; i < sellQuizInst.questions.length; i++) {
      var q = sellQuizInst.questions[i];
      var id = q.idx;
      var questionHtmlElement = getHtmlChildElementRecursive(htmlDivElement, 'sell_question_html_element_' + id);
      setQuestionHtmlElement(id, questionHtmlElement);
      refreshQuestion(id);
    }

    return true;
  }
  /**
   * Evaluates a quiz that has been created by autoCreateQuiz(..). This function is called automatically.
   * @param questionID Question index.
   * @param htmlQuestionElementID Identifier of the (global) HTML element that contains all questions.
   * @returns Success.
   */


  function autoEvaluateQuiz(questionID, htmlQuestionElementID) {
    var htmlQuestionElement = document.getElementById(htmlQuestionElementID);
    sellassert(htmlQuestionElement != null, "autoEvaluateQuiz(..): question HTML element is null");
    readStudentAnswersFromHtmlElements(questionID);
    if (evaluateQuestion(questionID) == false) return false;
    autoEvaluateQuiz2(questionID, htmlQuestionElement);
    return true;
  } // TODO: doc (this is an internal function)


  function autoEvaluateQuiz2(questionID, htmlQuestionElement) {
    var evalReady = sellQuizInst.evaluate.isEvaluationReady(questionID);

    if (!evalReady) {
      setTimeout(function () {
        autoEvaluateQuiz2(questionID, htmlQuestionElement); // TODO: process return value??
      }, 100);
      return true;
    }

    writeFeedbackToHtmlElements(questionID);
    var htmlGeneralFeedbackElement = getHtmlChildElementRecursive(htmlQuestionElement, "general_feedback");
    sellassert(htmlGeneralFeedbackElement != null, "autoEvaluateQuiz(..): feedback HTML element is null");
    htmlGeneralFeedbackElement.innerHTML = getFeedbackText(questionID);
    return true;
  }
  /**
   * Sets the language for text outputs. Default is "en" := English.
   * @param langID Language identifier (one of {"en", "de"}).
   */


  function setLanguage(langID) {
    sellQuizInst.language = langID;
  }
  /**
   * Enables (or disables) the generation of HTML code for input and feedback element.
   * @param enable If false, then getQuestionBody() returns HTML code that includes only placeholders for input and feedback fields. Placeholders have the form '$$ID', where ID can be obtained by calling getQuestionInputFields().
   */


  function setGenerateInputFieldHtmlCode() {
    var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    sellQuizInst.generateInputFieldHtmlCode = enable;
  }
  /**
   * Creates a new question.
   * @param sellCode SELL source code of a single question.
   * @returns Question index or -1 in case of errors.
   */


  function createQuestion(sellCode) {
    if (sellQuizInst.importQuestion(sellCode) == false) return -1;
    return sellQuizInst.qidx;
  }
  /**
   * Creates a new question from a question backup (refer to function backupQuestion(..)).
   * @param questionBackup Backup string (stringified JSON).
   * @returns Question index or -1 in case of errors.
   */


  function createQuestionFromBackup(questionBackupStr) {
    return sellQuizInst.createQuestionFromBackup(questionBackupStr);
  }
  /**
   * Creates a backup of a question which includes internal states (for example random variables).
   * @param questionID Question index.
   * @resturns Stringified JSON object of the question state or null in case that an error occourred.
   */


  function backupQuestion(questionID) {
    return sellQuizInst.backupQuestion(questionID);
  }
  /**
   * Gets the input fields of a question. *
   * @param questionID Question index.
   * @returns Array of dictionaries with entries "element_id" for the HTML element identifier, "element_type" for the HTML element type (refer to enum SellInputElementType in file quiz.js) and "solution_variable_id" the identifier of the corresponding soluion variable.
   */


  function getQuestionInputFields(questionID) {
    return sellQuizInst.getQuestionInputFields(questionID);
  }
  /**
   * Gets the error log for the last created question.
   * @returns Error log.
   */


  function getErrorLog() {
    return sellQuizInst.log;
  }
  /**
   * Gets the question title.
   * @param questionID Question index.
   * @returns Title as HTML code or an empty string, if the question does not exist.
   */


  function getQuestionTitle(questionID) {
    var q = sellQuizInst.getQuestionByIdx(questionID);
    if (q == null) return "";
    return q.titleHtml;
  }
  /**
   * Gets the question body.
   * @param questionID Question index.
   * @returns Body as HTML code or an empty string, if the question does not exist.
   */


  function getQuestionBody(questionID) {
    var q = sellQuizInst.getQuestionByIdx(questionID);
    if (q == null) return "";
    return q.bodyHtml;
  }
  /**
   * Sets the HTML element that contains the question body (Alternatively, the element can also be a parent element of the question body). This function must be called once before calling "readStudentAnswersFromHtmlElements" or "writeFeedbackToHtmlElements".
   * @param questionID Question index.
   * @param element HTML element that contains the question body.
   * @returns Success.
   */


  function setQuestionHtmlElement(questionID, element) {
    var q = sellQuizInst.getQuestionByIdx(questionID);
    if (q == null) return false;
    q.bodyHtmlElement = element;
    return true;
  }
  /**
   * Evaluates the student answers of a question. This function does NOT read and write HTML elements. Also refer to functions "readStudentAnswersFromHtmlElements" and "writeFeedbackToHtmlElements".
   * @param questionID Question index.
   * @returns Success.
   */


  function evaluateQuestion(questionID) {
    return sellQuizInst.evaluate.evaluate(questionID);
  }
  /**
   * Reads student answers from HTML elements. Also refer to functions "evaluateQuestion" and "writeFeedbackToHtmlElements".
   * @param questionID Question index.
   * @returns Success.
   */


  function readStudentAnswersFromHtmlElements(questionID) {
    return sellQuizInst.evaluate.getStudentAnswers(questionID);
  }
  /**
   * Sets a student answer string manually. Also refer to functions "getInputElements" and "backupQuestion"
   * @param questionID Question index.
   * @param htmlElementId HTML element identifier.
   * @param answerStr Answer string in ASCII-math encoding (e.g. "a+bi" for complex numbers, "[a,b,c]" for vectors, "[[a,b],[c,d]]" for matrices).
   * @returns Success.
   */


  function setStudentAnswerManually(questionID, solutionVariableID, answerStr) {
    return sellQuizInst.evaluate.setStudentAnswerManually(questionID, solutionVariableID, answerStr);
  }
  /**
   * Writes feedback to HTML elements. Also refer to functions "evaluateQuestion" and "readStudentAnswersFromHtmlElements".
   * @param questionID Question index.
   * @returns Success.
   */


  function writeFeedbackToHtmlElements(questionID) {
    return sellQuizInst.evaluate.displayFeedback(questionID);
  }
  /**
   * Gets the feedback text of an already evaluated question.
   * @param questionID Question Index.
   * @returns Success.
   */


  function getFeedbackText(questionID) {
    var q = sellQuizInst.getQuestionByIdx(questionID);
    if (q == null) return "";
    return q.generalFeedbackStr;
  }
  /**
   * Gets the evaluation score of an already evaluted question.
   * @param questionID Question Index.
   * @returns Score in range [0, 1]
   */


  function getScore(questionID) {
    return sellQuizInst.evaluate.getScore(questionID);
  }
  /**
   * Enables all input field HTML elements for editing.
   * @param questionID Question index.
   * @returns Success.
   */


  function enableInputFields(questionID) {
    return sellQuizInst.enableInputFields(questionID, false);
  }
  /**
   * Disables all input field HTML elements for editing.
   * @param questionID Question index.
   * @returns Success.
   */


  function disableInputFields(questionID) {
    return sellQuizInst.enableInputFields(questionID, false);
  }
  /**
   * Refreshes the HTML elements of a questions. This is mainly required for matrices that can be resized by students. This function is mainly called internally.
   * @param questionID Question index.
   * @returns Success.
   */


  function refreshQuestion(questionID) {
    if (sellQuizInst.updateMatrixInputs(questionID) == false) return false;
    if (sellQuizInst.createProgrammingTaskEditors(questionID) == false) return false;
    return true;
  }
  /**
   * Updates the number of rows and columns of a matrix input. Thes function is mainly called internally.
   * @param questionID Question index.
   * @param htmlElementId Identifier of the corresponding matrix input HTML element.
   * @param deltaRows Number of rows added (subtracted).
   * @param deltaCols Number of columns added (subtracted).
   * @returns Success.
   */


  function refreshMatrixDimensions(questionID, matrixId, deltaRows, deltaCols) {
    return sellQuizInst.updateMatrixDims(questionID, matrixId, deltaRows, deltaCols);
  } // TODO:


  function __ideCreationFuntion(fct) {
    sellQuizInst.createIDE = fct;
  }

  exports.__ideCreationFuntion = __ideCreationFuntion;
  exports.autoCreateQuiz = autoCreateQuiz;
  exports.autoEvaluateQuiz = autoEvaluateQuiz;
  exports.backupQuestion = backupQuestion;
  exports.createQuestion = createQuestion;
  exports.createQuestionFromBackup = createQuestionFromBackup;
  exports.disableInputFields = disableInputFields;
  exports.enableInputFields = enableInputFields;
  exports.evaluateQuestion = evaluateQuestion;
  exports.getErrorLog = getErrorLog;
  exports.getFeedbackText = getFeedbackText;
  exports.getQuestionBody = getQuestionBody;
  exports.getQuestionInputFields = getQuestionInputFields;
  exports.getQuestionTitle = getQuestionTitle;
  exports.getScore = getScore;
  exports.readStudentAnswersFromHtmlElements = readStudentAnswersFromHtmlElements;
  exports.refreshMatrixDimensions = refreshMatrixDimensions;
  exports.refreshQuestion = refreshQuestion;
  exports.reset = reset;
  exports.setGenerateInputFieldHtmlCode = setGenerateInputFieldHtmlCode;
  exports.setLanguage = setLanguage;
  exports.setQuestionHtmlElement = setQuestionHtmlElement;
  exports.setStudentAnswerManually = setStudentAnswerManually;
  exports.writeFeedbackToHtmlElements = writeFeedbackToHtmlElements;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}, math, $));
